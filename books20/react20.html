<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React 文档总结思考 | 读书笔记</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/reading-notes/avatar.png">
    <meta name="description" content="小白龙的前端读书笔记">
    
    <link rel="preload" href="/reading-notes/assets/css/0.styles.9653101a.css" as="style"><link rel="preload" href="/reading-notes/assets/js/app.3c3209d0.js" as="script"><link rel="preload" href="/reading-notes/assets/js/2.a1b00631.js" as="script"><link rel="preload" href="/reading-notes/assets/js/17.91297be8.js" as="script"><link rel="prefetch" href="/reading-notes/assets/js/10.b01eb44d.js"><link rel="prefetch" href="/reading-notes/assets/js/11.7a9ed704.js"><link rel="prefetch" href="/reading-notes/assets/js/12.326518b6.js"><link rel="prefetch" href="/reading-notes/assets/js/13.bb903b42.js"><link rel="prefetch" href="/reading-notes/assets/js/14.f8bb1bef.js"><link rel="prefetch" href="/reading-notes/assets/js/15.fc976780.js"><link rel="prefetch" href="/reading-notes/assets/js/16.985c71fb.js"><link rel="prefetch" href="/reading-notes/assets/js/3.e746fc3a.js"><link rel="prefetch" href="/reading-notes/assets/js/4.bbac7c20.js"><link rel="prefetch" href="/reading-notes/assets/js/5.a9f838c3.js"><link rel="prefetch" href="/reading-notes/assets/js/6.514d7ebf.js"><link rel="prefetch" href="/reading-notes/assets/js/7.7c73e3c9.js"><link rel="prefetch" href="/reading-notes/assets/js/8.d947842c.js"><link rel="prefetch" href="/reading-notes/assets/js/9.6eecae53.js">
    <link rel="stylesheet" href="/reading-notes/assets/css/0.styles.9653101a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/reading-notes/" class="home-link router-link-active"><img src="/reading-notes/avatar.png" alt="读书笔记" class="logo"> <span class="site-name can-hide">读书笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://xblcity.github.io/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/xblcity/reading-notes" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://xblcity.github.io/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/xblcity/reading-notes" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/reading-notes/" aria-current="page" class="sidebar-link">总览</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>2019年</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/reading-notes/books19/professional-javascript.html" class="sidebar-link">Javascript高级程序设计(第三版)读书笔记</a></li><li><a href="/reading-notes/books19/understanding-es6.html" class="sidebar-link">深入理解ES6</a></li><li><a href="/reading-notes/books19/you-don't-know-js1.html" class="sidebar-link">你不知道的Javascript(上卷)</a></li><li><a href="/reading-notes/books19/understanding-node.html" class="sidebar-link">深入浅出node.js</a></li><li><a href="/reading-notes/books19/understanding-webpack.html" class="sidebar-link">深入浅出webpack</a></li><li><a href="/reading-notes/books19/react.html" class="sidebar-link">React Docs(英译中)</a></li><li><a href="/reading-notes/books19/vue.html" class="sidebar-link">vue2.x文档</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>2020年</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/reading-notes/books20/functional-javascript.html" class="sidebar-link">Javascript ES6 函数式编程入门经典</a></li><li><a href="/reading-notes/books20/react20.html" aria-current="page" class="active sidebar-link">React 文档总结思考</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#hello-word" class="sidebar-link">Hello Word</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#jsx-简介" class="sidebar-link">JSX 简介</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#元素渲染" class="sidebar-link">元素渲染</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#组件-props" class="sidebar-link">组件 &amp; Props</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#state-生命周期" class="sidebar-link">State &amp; 生命周期</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#事件处理" class="sidebar-link">事件处理</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#条件渲染" class="sidebar-link">条件渲染</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#列表-key" class="sidebar-link">列表 &amp; key</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#表单" class="sidebar-link">表单</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#状态提升" class="sidebar-link">状态提升</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#组合-vs-继承" class="sidebar-link">组合 VS 继承</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#react-哲学" class="sidebar-link">React 哲学</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#无障碍" class="sidebar-link">无障碍</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#代码分割" class="sidebar-link">代码分割</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#context" class="sidebar-link">Context</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#错误边界" class="sidebar-link">错误边界</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#refs-转发" class="sidebar-link">Refs 转发</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#fragment" class="sidebar-link">Fragment</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#高阶组件" class="sidebar-link">高阶组件</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#与第三方库协同" class="sidebar-link">与第三方库协同</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#深入-jsx" class="sidebar-link">深入 JSX</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#性能优化" class="sidebar-link">性能优化</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#portals" class="sidebar-link">Portals</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#profiler" class="sidebar-link">Profiler</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#不适用-es6" class="sidebar-link">不适用 ES6</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#不使用-jsx-的-react" class="sidebar-link">不使用 JSX 的 React</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#协调-reconciliation" class="sidebar-link">协调(reconciliation)</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#refs-and-the-dom" class="sidebar-link">Refs and the DOM</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#render" class="sidebar-link">Render</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#静态类型检查" class="sidebar-link">静态类型检查</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#严格模式" class="sidebar-link">严格模式</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#使用-proptypes-类型检查" class="sidebar-link">使用 PropTypes 类型检查</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#非受控组件" class="sidebar-link">非受控组件</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#web-components" class="sidebar-link">Web Components</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#react" class="sidebar-link">React</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#react-component" class="sidebar-link">React.Component</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#reactdom" class="sidebar-link">ReactDOM</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#reactdomserver" class="sidebar-link">ReactDOMServer</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#dom-元素" class="sidebar-link">DOM 元素</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#合成事件" class="sidebar-link">合成事件</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#test-utilities" class="sidebar-link">Test Utilities</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#test-renderer" class="sidebar-link">Test Renderer</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#javascript环境要求" class="sidebar-link">Javascript环境要求</a></li><li class="sidebar-sub-header"><a href="/reading-notes/books20/react20.html#术语表" class="sidebar-link">术语表</a></li></ul></li><li><a href="/reading-notes/books20/node-in-action.html" class="sidebar-link">Node.js实战 第二版 2018</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react-文档总结思考"><a href="#react-文档总结思考" class="header-anchor">#</a> React 文档总结思考</h1> <p><a href="https://zh-hans.reactjs.org/docs/getting-started.html" target="_blank" rel="noopener noreferrer">文档链接<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>版本: v16.13.1</p> <p>系统的把 react 文档读一遍，查漏补缺之前没有注意到的点。</p> <ul><li>安装</li> <li>核心概念</li> <li>高级指引</li> <li>API REFERENCE</li> <li>HOOK</li> <li>测试</li> <li>CONCURRENT 模式(实验阶段)</li> <li>贡献</li> <li>FAQ</li></ul> <h2 id="hello-word"><a href="#hello-word" class="header-anchor">#</a> Hello Word</h2> <h2 id="jsx-简介"><a href="#jsx-简介" class="header-anchor">#</a> JSX 简介</h2> <p>WHY &amp; WHAT</p> <ul><li>为了能够在 JS 中使用标记语言</li> <li>JSX 最终会被 babel 转译成名为 <code>React.createElement()</code> 函数调用</li></ul> <h2 id="元素渲染"><a href="#元素渲染" class="header-anchor">#</a> 元素渲染</h2> <ul><li><code>ReactDOM.render()</code> 用于将 <code>React</code> 元素渲染到 <code>DOM</code> 节点</li> <li>想要改变 <code>DOM</code> 节点内容，可以重新调用 <code>ReactDOM.render()</code> ，或者把要改变的内容放入状态中，控制状态的改变来触发 <code>re-render</code></li> <li><code>React</code> 在更新时会与之前状态进行比对，只更新它需要更新的部分</li></ul> <h2 id="组件-props"><a href="#组件-props" class="header-anchor">#</a> 组件 &amp; Props</h2> <ul><li>组件首字母必须大写，因为 babel 会根据这个进行不同形式的转换</li></ul> <h2 id="state-生命周期"><a href="#state-生命周期" class="header-anchor">#</a> State &amp; 生命周期</h2> <ul><li>生命周期： <code>class</code> 组件声明的特殊的方法，在组件挂载，卸载时会执行这些方法</li> <li>直接修改 <code>state</code> 不会触发组件的重新渲染</li> <li><code>state</code> 更新可能是异步的，具体场景？</li> <li><code>state</code> 更新合并，为了避免这个，可以给 <code>setState</code> 传递回调</li></ul> <h2 id="事件处理"><a href="#事件处理" class="header-anchor">#</a> 事件处理</h2> <ul><li>驼峰命名</li> <li>阻止事件默认行为使用<code>preventDefault</code>，<code>return false</code>无法生效</li></ul> <p>定义处理事件处理函数的方法形式</p> <ul><li>在 <code>class</code> 中定义方法，并且在 <code>constructor</code> 使用 <code>bind</code> 对 <code>this</code> 进行绑定。在 <code>class</code> 中定义的方法默认会被挂载到 <code>class</code> 的原型链上</li> <li>属性初始化(实例属性新写法)，因为这种新语法可以使用箭头函数。属性初始化需要与静态属性/静态方法进行区分。</li> <li>在 <code>class</code> 中定义方法，在回调中使用进行箭头函数。<code>onClick={() =&gt; this.handleClick()}</code></li></ul> <p>传递参数的两种形式，分别使用箭头函数和 <code>bind</code> 实现,使用 <code>bind</code> 事件对象会被隐式的进行传递</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">deleteRow</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>Delete Row<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">deleteRow</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>Delete Row<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
</code></pre></div><h2 id="条件渲染"><a href="#条件渲染" class="header-anchor">#</a> 条件渲染</h2> <ul><li>与运算符&amp; 三目运算符 <code>condition ? true : false</code></li> <li>返回 null 可以阻止组件渲染</li></ul> <h2 id="列表-key"><a href="#列表-key" class="header-anchor">#</a> 列表 &amp; key</h2> <ul><li>为什么 key 是必须的</li> <li>索引作为 key 的负面影响</li></ul> <h2 id="表单"><a href="#表单" class="header-anchor">#</a> 表单</h2> <h2 id="状态提升"><a href="#状态提升" class="header-anchor">#</a> 状态提升</h2> <h2 id="组合-vs-继承"><a href="#组合-vs-继承" class="header-anchor">#</a> 组合 VS 继承</h2> <ul><li>有些组件无法提前知道子组件的具体内容，比如 <code>sidebar dialog</code>，这些组件可以使用 <code>children prop</code> 将子组件进行渲染</li> <li>上述场景也可以不使用 <code>children</code>，将所需的内容传入 <code>prop</code>，并使用对应的 <code>prop</code>，比如<code>&lt;SplitPane left={&lt;Contacts /&gt;} right={&lt;Chat /&gt;} /&gt;</code></li> <li><code>react</code> 组件不需要继承，复用只需要直接引入即可</li></ul> <h2 id="react-哲学"><a href="#react-哲学" class="header-anchor">#</a> React 哲学</h2> <ul><li>对 UI 划分组件层级</li> <li>自上而下或者自下而上构建应用，当应用比较简单时，使用自上而下的方式更方便，对于较大型的项目，自下而上构建，并同时为低层组件编写测试是更简单的方式</li> <li>确定 state 位置</li> <li>添加反向数据流-即能触发 state 改变的回调函数</li></ul> <p>如何确定 state 放置的位置</p> <ul><li>找到根据这个 state 进行渲染的所有组件</li> <li>找到他们的共同所有者组件</li> <li>该共同所有者组件是否拥有该 state</li> <li>如果你找不到一个合适的位置来存放该 state，就可以直接创建一个新的组件来存放该 state，并将这一新组件置于高于共同所有者组件层级的位置。？</li></ul> <blockquote><p>==============高级指引================</p></blockquote> <h2 id="无障碍"><a href="#无障碍" class="header-anchor">#</a> 无障碍</h2> <h2 id="代码分割"><a href="#代码分割" class="header-anchor">#</a> 代码分割</h2> <p>WHY &amp; WHAT</p> <ul><li>背景：随着应用变大，代码包也会变大，会导致加载时间过长</li> <li>目的：对代码进行分割能够帮助你“懒加载”当前用户需要的内容，能够显著提高应用的性能，可以避免加载用户不需要的代码，并在初始加载时减少所需加载的代码量</li></ul> <p>HOW</p> <ul><li>在 webpack 中使用 import-then 语法</li> <li>使用 React.lazy，可以结合 Suspense 使用(用于处理组件加载时的 loading)</li> <li>使用 Loadable Component 库，支持服务端渲染</li></ul> <h2 id="context"><a href="#context" class="header-anchor">#</a> Context</h2> <ul><li>场景：很多不同层级的组件需要访问相同的数据</li></ul> <p>使用</p> <p>1.使用 <code>React.createContext(初始值)</code> 创建一个 <code>Context</code> 对象，该对象包含 <code>Provider</code> 以及 <code>Consumer</code> 两个属性(两个属性都是 react 组件) 2.在 <code>Provider</code> 中定义要向下传递的 <code>value</code> 3.在 class 中使用 value，通过静态属性 <code>contextType</code> 接收 <code>Context</code> 对象，在 class 内部就可以直接使用 <code>this.context</code> 获取到 value 4.在函数组件中使用，需要使用 <code>Consumer</code>，并通过 <code>render-props</code>(函数作为子元素) 的形式获取到 value 值</p> <h2 id="错误边界"><a href="#错误边界" class="header-anchor">#</a> 错误边界</h2> <ul><li>只要在 class 组件中定义了<code>static getDerivedStateFromError</code> 或 <code>componentDidCatch</code> 时，它就会变成一个错误边界，可以当做组件进行使用</li></ul> <h2 id="refs-转发"><a href="#refs-转发" class="header-anchor">#</a> Refs 转发</h2> <ul><li>场景：父组件给子组件传递 ref，(常规函数和 class 组件不接受 ref 参数，且 props 中也不存在 ref)</li> <li>使用 React.forwardRef 可以对 ref 进行转发</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 定义组件，接收ref</span>
<span class="token keyword">const</span> FancyButton <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> ref</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>button ref<span class="token operator">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span> className<span class="token operator">=</span><span class="token string">&quot;FancyButton&quot;</span><span class="token operator">&gt;</span>
    <span class="token punctuation">{</span>props<span class="token punctuation">.</span>children<span class="token punctuation">}</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用组件，定义ref</span>
<span class="token keyword">const</span> ref <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span>FancyButton ref<span class="token operator">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span><span class="token operator">&gt;</span>Click me<span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>FancyButton<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>在 HOC 中实现透传(pass through)props 到包裹的组件</li></ul> <h2 id="fragment"><a href="#fragment" class="header-anchor">#</a> Fragment</h2> <ul><li>避免渲染多余 <code>DOM</code> 元素，支持 <code>key</code> 属性，<code>&lt;&gt;&lt;/&gt;</code>不支持 <code>key</code> 属性</li></ul> <h2 id="高阶组件"><a href="#高阶组件" class="header-anchor">#</a> 高阶组件</h2> <ul><li>应用场景: 两个组件具备相同的逻辑，仅仅是 props 不同。可以抽成一个高阶组件</li></ul> <p>注意事项</p> <ul><li>不要改变原始组件，比如改变原始子组件 prototype 上面的生命周期函数</li> <li>透传与本身无关的 props</li> <li>接收两个参数，可以最大化组合，其中第二个参数才是组件，比如 withRouter 高阶组件</li> <li>通过设置 displayName 属性，方便在 dev tools 用于调试</li> <li>不要在 render 方法中使用 HOC，函数式组件不应该在函数内部使用 HOC，这两种都会导致 HOC 的重新挂载与卸载</li> <li>传递 ref 需要使用 React.forwardRef</li></ul> <h2 id="与第三方库协同"><a href="#与第三方库协同" class="header-anchor">#</a> 与第三方库协同</h2> <ul><li>在 <code>componentDidMount</code> 生命周期 注册第三方库实例，在组件卸载时销毁实例</li></ul> <h2 id="深入-jsx"><a href="#深入-jsx" class="header-anchor">#</a> 深入 JSX</h2> <ul><li>JSX 只是 React.createElement()的语法糖</li> <li>因为 JSX 会编译为 React.createElement 调用形式，所以 React 库必须包含在 JSX 代码作用域内</li> <li>在 JSX 标签中使用 . 语法</li> <li>动态加载 不同组件</li> <li>...</li></ul> <h2 id="性能优化"><a href="#性能优化" class="header-anchor">#</a> 性能优化</h2> <ul><li>组件使用 PureComponent, 浅比较策略？</li> <li>使用不可变数据</li></ul> <h2 id="portals"><a href="#portals" class="header-anchor">#</a> Portals</h2> <p>?</p> <h2 id="profiler"><a href="#profiler" class="header-anchor">#</a> Profiler</h2> <p>?</p> <h2 id="不适用-es6"><a href="#不适用-es6" class="header-anchor">#</a> 不适用 ES6</h2> <ul><li>需要用到<code>react-create-class</code></li></ul> <h2 id="不使用-jsx-的-react"><a href="#不使用-jsx-的-react" class="header-anchor">#</a> 不使用 JSX 的 React</h2> <ul><li>每个 JSX 元素知识调用 React.crateElement(component, props, ...children)的语法糖，组件可以是字符串，或者是 Component 的子类，也可以是一个普通的函数</li></ul> <h2 id="协调-reconciliation"><a href="#协调-reconciliation" class="header-anchor">#</a> 协调(reconciliation)</h2> <ul><li>react differ 策略</li> <li>对子节点递归，当没有 key 时，更新开销可能会比较大，比如在列表的头部插入一个新的节点</li></ul> <h2 id="refs-and-the-dom"><a href="#refs-and-the-dom" class="header-anchor">#</a> Refs and the DOM</h2> <ul><li>可以在 class 组件直接使用 ref 从而获取该 class 组件的实例，但是不能直接用于函数组件上，因为他们没有实例</li> <li>函数式组件可以使用 forwardRef 来接收 refs, 结合 useImperativeHandle 可以向外暴露 refs</li> <li>将 DON refs 暴露给父组件？ refs 暴露给子组件需要使用 React.forwardRef，或者可以通过 ref 回调函数的形式进行传递</li></ul> <h2 id="render"><a href="#render" class="header-anchor">#</a> Render</h2> <ul><li>render-props 会抵消 React.PureComponent 的效果，因为浅比较都会得到 false，每次 render 都会产生一个新的函数，解决方法是定义实例方法</li></ul> <h2 id="静态类型检查"><a href="#静态类型检查" class="header-anchor">#</a> 静态类型检查</h2> <ul><li>使用 typescript</li></ul> <h2 id="严格模式"><a href="#严格模式" class="header-anchor">#</a> 严格模式</h2> <ul><li>有助于识别不安全的生命周期或者过时以及废弃的 api 等</li></ul> <h2 id="使用-proptypes-类型检查"><a href="#使用-proptypes-类型检查" class="header-anchor">#</a> 使用 PropTypes 类型检查</h2> <ul><li>需要使用 prop-types 第三方包</li></ul> <h2 id="非受控组件"><a href="#非受控组件" class="header-anchor">#</a> 非受控组件</h2> <ul><li>对于 Input 可以使用 ref.current.value 获取表单值</li> <li>input type=file 始终是非受控组件，它的值只能由用户设置，而不能通过代码控制</li></ul> <h2 id="web-components"><a href="#web-components" class="header-anchor">#</a> Web Components</h2> <ul><li>谷歌推出的浏览器的原生组件</li></ul> <blockquote><p>=======API REFERENCE=========</p></blockquote> <h2 id="react"><a href="#react" class="header-anchor">#</a> React</h2> <ul><li>React 导出的一些 api</li></ul> <h2 id="react-component"><a href="#react-component" class="header-anchor">#</a> React.Component</h2> <ul><li>class 组件声明周期及注意事项</li></ul> <h2 id="reactdom"><a href="#reactdom" class="header-anchor">#</a> ReactDOM</h2> <h2 id="reactdomserver"><a href="#reactdomserver" class="header-anchor">#</a> ReactDOMServer</h2> <h2 id="dom-元素"><a href="#dom-元素" class="header-anchor">#</a> DOM 元素</h2> <ul><li>与普通 html 的差异</li></ul> <h2 id="合成事件"><a href="#合成事件" class="header-anchor">#</a> 合成事件</h2> <h2 id="test-utilities"><a href="#test-utilities" class="header-anchor">#</a> Test Utilities</h2> <h2 id="test-renderer"><a href="#test-renderer" class="header-anchor">#</a> Test Renderer</h2> <h2 id="javascript环境要求"><a href="#javascript环境要求" class="header-anchor">#</a> Javascript环境要求</h2> <h2 id="术语表"><a href="#术语表" class="header-anchor">#</a> 术语表</h2> <p>元素、组件、props、props.children、state、</p> <p>声明周期方法、受控&amp;非受控组件、key</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/reading-notes/books20/functional-javascript.html" class="prev">
        Javascript ES6 函数式编程入门经典
      </a></span> <span class="next"><a href="/reading-notes/books20/node-in-action.html">
        Node.js实战 第二版 2018
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><div id="live2d-widget" class="live2d-widget-container" style="position:fixed;right:15px;bottom:60px;width:150px;height:300px;z-index:99999;opacity:0.8;pointer-events:none;"><canvas id="live2d_canvas" width="150" height="300" class="live2d_canvas" style="position:absolute;left:0px;top:0px;width:150px;height:300px;"></canvas></div></div></div>
    <script src="/reading-notes/assets/js/app.3c3209d0.js" defer></script><script src="/reading-notes/assets/js/2.a1b00631.js" defer></script><script src="/reading-notes/assets/js/17.91297be8.js" defer></script>
  </body>
</html>
